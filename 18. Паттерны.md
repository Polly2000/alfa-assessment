# Junior
# 1. Что такое паттерны проектирования, как они помогают при написании кода

 Паттерны проектирования - это повторно используемые архитектурные решения, которые помогают решать типичные проблемы при разработке программного обеспечения. Они представляют собой bewell-установленные подходы к организации кода и взаимодействию между компонентами системы. "Bewell-установленные подходы к организации кода" означает, что паттерны проектирования являются широко принятыми и признанными способами структурирования, организации и написания кода в различных ситуациях. Они основаны на опыте и лучших практиках разработки программного обеспечения, которые были установлены со временем.

Паттерны проектирования помогают при написании кода в нескольких аспектах:

1. Решение типичных проблем: Паттерны проектирования предлагают проверенные подходы к решению распространенных проблем разработки, таких как управление зависимостями, обработка входных данных, синхронизация потоков и другие.

2. Улучшение читаемости и поддерживаемости: Паттерны проектирования предоставляют стандартизированный язык для описания архитектурных решений, что делает код более читаемым и понятным для других разработчиков. Они также способствуют лучшей организации кода, упрощая его поддержку и изменение в будущем.

3. Повторное использование кода: Паттерны проектирования предлагают готовые абстракции и решения, которые можно применять повторно в разных проектах. Это помогает улучшить производительность разработки и сократить время написания кода.

4. Облегчение командной разработки: Паттерны проектирования предоставляют общий язык и подходы к проектированию, что упрощает взаимодействие и понимание между членами команды разработчиков. Они также способствуют разделению ответственности и улучшению координации при разработке больших проектов.

Некоторые из известных паттернов проектирования включают Singleton, Factory, Observer, Decorator, Strategy, MVC и другие. Каждый из них предоставляет решение для определенного типа проблемы в контексте проектирования программного обеспечения.

# Junior+
# 1. Паттерны:
## 1.1. Command

Паттерн проектирования **Command (Команда)** относится к категории поведенческих паттернов. Он предназначен для инкапсуляции запроса в виде объекта, позволяя параметризовать клиентские запросы. Паттерн Command позволяет отделить отправителя запроса от его получателя и позволяет легко добавлять новые типы запросов без изменения существующего кода.

Основные компоненты паттерна Command:

1. **Command (Команда):** определяет общий интерфейс для всех конкретных команд.
2. **ConcreteCommand (Конкретная команда):** реализует интерфейс Command и связывает команду с получателем. Он содержит ссылку на объект Receiver и определяет, какие операции должны быть выполнены при вызове команды.
3. **Receiver (Получатель):** выполняет фактические операции, связанные с выполнением команд.
4. **Invoker (Инициатор):** инициирует выполнение команды путем вызова ее метода execute().
5. **Client (Клиент):** создает объекты команд и настраивает их параметры, затем передает команды в Invoker для выполнения.

**Преимущества использования паттерна Command:**

1. Изолирует отправителя запроса от получателя, позволяя легко добавлять новые типы команд.
2. Поддерживает отмену операций и хранение истории выполненных команд.
3. Облегчает добавление новых команд без изменения существующего кода.
4. Позволяет сгруппировать операции в комплексные команды.

Во фронтенд-разработке паттерн Command часто применяется для управления действиями и событиями пользовательского интерфейса. Вот несколько примеров применения паттерна Command во фронтенд-разработке:

1. Кнопки и обработчики событий: Когда пользователь нажимает на кнопку или выполняет определенное действие, можно использовать паттерн Command для инкапсуляции этого действия в отдельный объект команды. Такой объект может содержать всю необходимую логику и данные для выполнения команды. Например, при клике на кнопку "Отправить" можно создать объект команды "Отправить форму", который будет содержать логику отправки данных на сервер.

2. История действий и отмена операций: Паттерн Command позволяет сохранять историю выполненных команд, что может быть полезно для реализации функциональности отмены и повтора операций. Каждая команда может иметь методы undo и redo, которые позволяют отменить или повторить выполнение команды. Например, при редактировании текста в редакторе можно использовать команды для вставки, удаления или форматирования текста, и пользователь сможет отменить или повторить эти операции.

3. Контекстное меню и выпадающие списки: При работе с контекстными меню или выпадающими списками можно использовать паттерн Command для связывания команд с определенными пунктами меню или элементами списка. Каждый пункт меню или элемент списка может быть представлен отдельным объектом команды, который будет выполнять определенное действие при выборе. Например, в контекстном меню изображения можно иметь команды для изменения размера, поворота или удаления изображения.

**Пример применения паттерна Command в JavaScript:**

```javascript
// Интерфейс команды
class Command {
  execute() {}
}

// Конкретная команда - открытие модального окна
class OpenModalCommand extends Command {
  constructor(modal) {
    super();
    this.modal = modal;
  }

  execute() {
    this.modal.open();
  }
}

// Конкретная команда - закрытие модального окна
class CloseModalCommand extends Command {
  constructor(modal) {
    super();
    this.modal = modal;
  }

  execute() {
    this.modal.close();
  }
}

// Объект, который будет выполнять команды
class CommandExecutor {
  executeCommand(command) {
    command.execute();
  }
}

// Пример использования
const modal = {
  open() {
    console.log("Модальное окно открыто");
  },
  close() {
    console.log("Модальное окно закрыто");
  }
};

const commandExecutor = new CommandExecutor();

// Создаем команды
const openModalCommand = new OpenModalCommand(modal);
const closeModalCommand = new CloseModalCommand(modal);

// Выполняем команды
commandExecutor.executeCommand(openModalCommand); // Вывод: "Модальное окно открыто"
commandExecutor.executeCommand(closeModalCommand); // Вывод: "Модальное окно закрыто"
```

В этом примере паттерн Command используется для управления открытием и закрытием модального окна. Команды `OpenModalCommand` и `CloseModalCommand` представляют соответствующие действия и содержат логику для выполнения этих действий. Объект `CommandExecutor` выполняет команды, вызывая их метод `execute()`. При выполнении команд модальное окно открывается или закрывается, и соответствующее сообщение выводится в консоль.

Это лишь несколько примеров, где паттерн Command может быть применен во фронтенд-разработке. Он обеспечивает гибкость, разделение ответственности и управление действиями в приложении, делая код более поддерживаемым и расширяемым.

## 1.2. Facede

Паттерн проектирования **Facade (Фасад)** является структурным паттерном, который предоставляет унифицированный интерфейс к набору интерфейсов в подсистеме. Он обеспечивает более простой способ взаимодействия клиента с комплексной системой, скрывая детали реализации и предоставляя упрощенный интерфейс.

Основная идея паттерна Facade заключается в создании "фасада", который предоставляет единый точку входа для клиента, скрывая сложность внутренней структуры и взаимодействия подсистем. Фасад управляет вызовами методов подсистемы, обеспечивая правильную последовательность вызовов и координацию действий.

**Преимущества использования паттерна Facade включают:**

1. Упрощение взаимодействия с комплексными системами, предоставляя единый и понятный интерфейс.
2. Сокрытие деталей реализации и внутренней структуры системы, обеспечивая легкость поддержки и изменений.
3. Уменьшение связанности между клиентом и подсистемой, что способствует снижению зависимостей и повышению гибкости системы.
4. Повышение уровня абстракции и понимания для клиентского кода.

Пример применения паттерна Facade во фронтенд-разработке может быть связан с работой с различными браузерными API, такими как работа с DOM, AJAX-запросы и другие.

 **Пример с работой с AJAX-запросами:**

```javascript
// Фасад для работы с AJAX-запросами
class AjaxFacade {
  static get(url, callback) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
        const response = JSON.parse(xhr.responseText);
        callback(response);
      }
    };
    xhr.send();
  }

  static post(url, data, callback) {
    const xhr = new XMLHttpRequest();
    xhr.open('POST', url);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
        const response = JSON.parse(xhr.responseText);
        callback(response);
      }
    };
    xhr.send(JSON.stringify(data));
  }
}

// Пример использования
function handleResponse(response) {
  console.log('Ответ сервера:', response);
}

AjaxFacade.get('https://api.example.com/data', handleResponse);
AjaxFacade.post('https://api.example.com/data', { name: 'John', age: 25 }, handleResponse);
```

В этом примере `AjaxFacade` предоставляет простой интерфейс для выполнения AJAX-запросов на получение данных (`get`) и отправку данных (`post`). Он скрывает сложности работы с объектом `XMLHttpRequest` и обработкой состояний и ответов от сервера.

При вызове методов `AjaxFacade.get` и `AjaxFacade.post` передается URL-адрес, данные (для метода `post`) и обратный вызов (`callback`), который будет вызван после получения ответа от сервера.

Таким образом, паттерн Facade помогает упростить и структурировать код, делая его более понятным и удобным для использования, а также улучшает модульность и гибкость системы.

## 1.3. Observer

Паттерн проектирования **Observer (Наблюдатель)** является поведенческим паттерном, который обеспечивает механизм уведомления об изменениях в объекте наблюдения всем заинтересованным объектам-наблюдателям. Он позволяет реализовать слабую связь между объектами и обеспечивает гибкую систему взаимодействия.

**Основная идея паттерна Observer заключается в создании двух основных компонентов:** объекта наблюдателя (Observer), который ожидает получения уведомлений об изменениях, и объекта наблюдаемого (Observable), который содержит данные и отправляет уведомления об изменениях своим наблюдателям.

Пример использования паттерна Observer во фронтенд-разработке может быть реализация паттерна "Pub-Sub" (публикация-подписка) для обработки событий на веб-странице. В этом случае, различные компоненты страницы (например, виджеты, модули) могут быть наблюдателями, которые подписываются на определенные события (например, клик на кнопку, изменение значения поля) и реагируют на них.

Пример кода на JavaScript:


```javascript
// Наблюдаемый объект - Кнопка
class Button {
  constructor() {
    this.clickHandlers = [];
  }

  // Метод для добавления обработчиков клика
  addClickHandler(handler) {
    this.clickHandlers.push(handler);
  }

  // Метод для удаления обработчиков клика
  removeClickHandler(handler) {
    const index = this.clickHandlers.indexOf(handler);
    if (index !== -1) {
      this.clickHandlers.splice(index, 1);
    }
  }

  // Метод для вызова обработчиков клика
  handleClick() {
    this.clickHandlers.forEach(handler => {
      handler();
    });
  }
}

// Обработчик клика - Вывод сообщения в консоль
function handleClick() {
  console.log('Кнопка нажата!');
}

// Создание объекта кнопки
const button = new Button();

// Добавление обработчика клика
button.addClickHandler(handleClick);

// Нажатие кнопки
button.handleClick();
```

В этом примере у нас есть наблюдаемый объект - кнопка (`Button`), который содержит массив обработчиков клика (`clickHandlers`). У кнопки есть методы для добавления и удаления обработчиков клика, а также для вызова обработчиков при клике на кнопку.

Мы также имеем обработчик клика (`handleClick`), который просто выводит сообщение в консоль.

Мы создаем объект кнопки и добавляем обработчик клика с помощью метода `addClickHandler()`. При нажатии кнопки с помощью метода `handleClick()`, все добавленные обработчики вызываются, и сообщение "Кнопка нажата!" выводится в консоль.

Таким образом, когда мы нажимаем на кнопку, все добавленные обработчики выполняют свои действия. Это демонстрирует паттерн Observer, где наблюдаемый объект (кнопка) уведомляет своих наблюдателей (обработчики клика) о событии (клик), и наблюдатели реагируют на это событие выполняя свои действия.




# Middle
# 1. Паттерны:
Паттерны разработки (или шаблоны проектирования) представляют собой повторяемые архитектурные решения, используемые для решения типичных проблем в проектировании программного обеспечения. Они представляют собой проверенные временем и принятые в индустрии способы организации кода, обеспечивающие гибкость, переиспользуемость и поддерживаемость системы.

## 1.1. Factory Method
Концепция **Factory Method** на TypeScript предполагает использование абстрактного класса для определения общего интерфейса создания объектов, а затем создание конкретных подклассов, реализующих этот интерфейс и предоставляющих собственную реализацию фабричного метода.

```ts
// Абстрактный класс транспортного средства
abstract class Transport {
  abstract deliver(): void;
}

// Конкретный класс автомобиля
class Car extends Transport {
  deliver(): void {
    console.log('Доставка автомобилем');
  }
}

// Конкретный класс велосипеда
class Bicycle extends Transport {
  deliver(): void {
    console.log('Доставка велосипедом');
  }
}

// Абстрактный класс фабрики
abstract class TransportFactory {
  abstract createTransport(): Transport;

  deliverTransport(): void {
    const transport = this.createTransport();
    transport.deliver();
  }
}

// Конкретная фабрика автомобилей
class CarFactory extends TransportFactory {
  createTransport(): Transport {
    return new Car();
  }
}

// Конкретная фабрика велосипедов
class BicycleFactory extends TransportFactory {
  createTransport(): Transport {
    return new Bicycle();
  }
}

// Пример использования
const carFactory: TransportFactory = new CarFactory();
carFactory.deliverTransport(); // Вывод: Доставка автомобилем

const bicycleFactory: TransportFactory = new BicycleFactory();
bicycleFactory.deliverTransport(); // Вывод: Доставка велосипедом
```

## 1.2. Prototype
Паттерн **Prototype** на TypeScript позволяет создавать объекты путем клонирования существующего объекта-прототипа. Это позволяет избежать создания объектов с нуля и дает возможность динамически создавать копии существующих объектов. 

```ts
// Абстрактный класс прототипа
abstract class Prototype {
  abstract clone(): Prototype;
}

// Конкретный класс прототипа
class ConcretePrototype extends Prototype {
  private state: number;

  constructor(state: number) {
    super();
    this.state = state;
  }

  clone(): Prototype {
    return new ConcretePrototype(this.state);
  }

  getState(): number {
    return this.state;
  }

  setState(state: number): void {
    this.state = state;
  }
}

// Пример использования
const prototype = new ConcretePrototype(123);
const clonedPrototype = prototype.clone();

console.log(prototype.getState()); // Вывод: 123
console.log(clonedPrototype.getState()); // Вывод: 123

clonedPrototype.setState(456);

console.log(prototype.getState()); // Вывод: 123
console.log(clonedPrototype.getState()); // Вывод: 456
```

В примере мы создаем прототипы объектов, которые реализуют метод `clone()`. Этот метод создает копию текущего объекта, возвращая новый объект того же типа. Затем мы используем этот метод для создания клонов объектов-прототипов.

Паттерн Прототип помогает создавать объекты более эффективно и гибко, особенно когда у нас есть сложные объекты, их создание требует больших затрат ресурсов или требуется создавать множество однотипных объектов.

## 1.3. Proxy
Паттерн **Proxy** (Заместитель) на TypeScript предоставляет объект-прокси, который контролирует доступ к другому объекту и позволяет добавлять дополнительную логику до и после доступа к нему.

```ts
// Интерфейс, определяющий общий функционал объекта
interface Subject {
  request(): void;
}

// Конкретный класс, реализующий функционал объекта
class RealSubject implements Subject {
  request(): void {
    console.log('RealSubject: Обработка запроса.');
  }
}

// Прокси класс
class Proxy implements Subject {
  private realSubject: RealSubject;

  constructor(realSubject: RealSubject) {
    this.realSubject = realSubject;
  }

  request(): void {
    // Дополнительная логика до вызова реального объекта
    console.log('Proxy: Подготовка к выполнению запроса.');

    // Вызов реального объекта
    this.realSubject.request();

    // Дополнительная логика после вызова реального объекта
    console.log('Proxy: Завершение выполнения запроса.');
  }
}

// Пример использования
const realSubject = new RealSubject();
const proxy = new Proxy(realSubject);

// Вызов метода через прокси
proxy.request();
```

В этом примере у нас есть интерфейс `Subject`, который определяет общий функционал объекта. Класс `RealSubject` реализует этот интерфейс и предоставляет реальную реализацию функционала.

Затем у нас есть класс Proxy, который также реализует интерфейс `Subject` и имеет внутри себя экземпляр RealSubject. При вызове метода `request()` через прокси, прокси добавляет дополнительную логику до и после вызова реального объекта. Это позволяет контролировать доступ к реальному объекту и добавлять дополнительное поведение.

В примере, при вызове метода `request()` через прокси, сначала выводится сообщение `"Proxy: Подготовка к выполнению запроса."`, затем вызывается метод `request()` реального объекта, и наконец выводится сообщение `"Proxy: Завершение выполнения запроса."`.

Таким образом, паттерн Proxy позволяет добавлять дополнительную функциональность и контролировать доступ к объекту без изменения его основной логики.

## 1.4. Singleton
Паттерн **Singleton** (Одиночка) на TypeScript обеспечивает создание только одного экземпляра класса и предоставляет глобальную точку доступа к этому экземпляру. 

```ts
class Singleton {
  private static instance: Singleton;
  private data: number;

  private constructor() {
    // Приватный конструктор для предотвращения создания экземпляров извне
    this.data = Math.random();
  }

  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }

  public getData(): number {
    return this.data;
  }
}

// Пример использования
const instance1 = Singleton.getInstance();
console.log(instance1.getData()); // Вывод: 0.12345

const instance2 = Singleton.getInstance();
console.log(instance2.getData()); // Вывод: 0.12345

console.log(instance1 === instance2); // Вывод: true
```

В этом примере класс `Singleton` имеет приватный статический член instance, который является единственным экземпляром класса. Конструктор класса является приватным, чтобы предотвратить создание экземпляров извне.

Статический метод `getInstance()` предоставляет глобальную точку доступа к экземпляру класса. Если экземпляр еще не создан, метод создает новый экземпляр класса, а затем возвращает его. При последующих вызовах метода `getInstance()` возвращается существующий экземпляр.

В примере мы создаем два экземпляра `Singleton` с помощью метода `getInstance()` и выводим их данные. Оба экземпляра имеют одно и то же значение данных, так как они являются одним и тем же экземпляром класса.

В конце примера мы проверяем, что `instance1` и `instance2` являются ссылками на один и тот же объект, выводя true.

Таким образом, паттерн `Singleton` обеспечивает гарантированное создание только одного экземпляра класса и предоставляет удобный доступ к этому экземпляру во всей программе.

## 1.5. Adapter
Паттерн **Adapter** (Адаптер) на TypeScript позволяет преобразовать интерфейс одного класса в интерфейс другого класса, чтобы они могли работать вместе.

```ts
// Интерфейс, который требуется адаптировать
interface Target {
  request(): void;
}

// Класс, который нужно адаптировать
class Adaptee {
  specificRequest(): void {
    console.log('Adaptee: Специфический запрос.');
  }
}

// Адаптер класса
class Adapter implements Target {
  private adaptee: Adaptee;

  constructor(adaptee: Adaptee) {
    this.adaptee = adaptee;
  }

  request(): void {
    console.log('Adapter: Адаптер выполняет запрос.');
    this.adaptee.specificRequest();
  }
}

// Пример использования
const adaptee = new Adaptee();
const adapter = new Adapter(adaptee);

// Вызов метода через адаптер
adapter.request();
```

В этом примере у нас есть интерфейс `Target`, который определяет требуемый интерфейс для клиентского кода. Класс `Adaptee` представляет собой существующий класс, интерфейс которого не соответствует интерфейсу `Target`, и его метод `specificRequest()` необходимо адаптировать.

Класс Adapter реализует интерфейс `Target` и внутри себя содержит экземпляр класса Adaptee. При вызове метода `request()` через адаптер, адаптер выполняет необходимые преобразования и вызывает метод `specificRequest()` у объекта `Adaptee`.

В примере, при вызове метода `request()` через адаптер, выводится сообщение `"Adapter: Адаптер выполняет запрос."`, а затем вызывается метод `specificRequest()` у объекта `Adaptee`, выводящий сообщение `"Adaptee: Специфический запрос."`.

Таким образом, паттерн `Adapter` позволяет классам с несовместимыми интерфейсами работать вместе, обеспечивая адаптацию вызовов методов и преобразование данных для совместимости.


# Middle+
# 1. Паттерны:
## 1.1. Chain of Responsibility
Паттерн **Chain of Responsibility** (Цепочка обязанностей) на TypeScript позволяет создать цепочку объектов, где каждый объект в цепочке имеет возможность обработать запрос или передать его следующему объекту в цепи. 

```ts
// Абстрактный класс обработчика
abstract class Handler {
  protected successor: Handler | null;

  public setSuccessor(successor: Handler): void {
    this.successor = successor;
  }

  public abstract handleRequest(request: string): void;
}

// Конкретный класс обработчика
class ConcreteHandlerA extends Handler {
  public handleRequest(request: string): void {
    if (request === 'A') {
      console.log('ConcreteHandlerA: Обработано запросом A.');
    } else if (this.successor) {
      this.successor.handleRequest(request);
    }
  }
}

// Конкретный класс обработчика
class ConcreteHandlerB extends Handler {
  public handleRequest(request: string): void {
    if (request === 'B') {
      console.log('ConcreteHandlerB: Обработано запросом B.');
    } else if (this.successor) {
      this.successor.handleRequest(request);
    }
  }
}

// Конкретный класс обработчика
class ConcreteHandlerC extends Handler {
  public handleRequest(request: string): void {
    if (request === 'C') {
      console.log('ConcreteHandlerC: Обработано запросом C.');
    } else if (this.successor) {
      this.successor.handleRequest(request);
    }
  }
}

// Пример использования
const handlerA = new ConcreteHandlerA();
const handlerB = new ConcreteHandlerB();
const handlerC = new ConcreteHandlerC();

handlerA.setSuccessor(handlerB);
handlerB.setSuccessor(handlerC);

// Передача запросов по цепочке
handlerA.handleRequest('B'); // Вывод: ConcreteHandlerB: Обработано запросом B.
handlerA.handleRequest('C'); // Вывод: ConcreteHandlerC: Обработано запросом C.
handlerA.handleRequest('D'); // Вывод: Запрос не может быть обработан.
```

В этом примере у нас есть абстрактный класс Handler, который определяет базовый функционал обработчика и имеет ссылку на следующий обработчик в цепочке.

Классы `ConcreteHandlerA`, `ConcreteHandlerB` и `ConcreteHandlerC` представляют конкретные обработчики и реализуют метод `handleRequest()`, который определяет способ обработки запроса. Если обработчик может обработать запрос, он выполняет соответствующие действия. Если не может, он передает запрос следующему обработчику в цепочке.

В примере мы создаем цепочку обработчиков, где handlerA передает запрос `handlerB`, а `handlerB` передает запрос `handlerC`.

При вызове метода `handleRequest()` у `handlerA` с разными запросами, каждый обработчик в цепочке проверяет, может ли он обработать запрос. Если может, то он выполняет соответствующие действия. Если не может, он передает запрос следующему обработчику.

В результате, при вызове `handlerA.handleRequest('B')`, обработка передается `handlerB`, который успешно обрабатывает запрос и выводит сообщение `"ConcreteHandlerB: Обработано запросом B."`. Аналогично, при вызове `handlerA.handleRequest('C')`, обработка передается `handlerC`, который успешно обрабатывает запрос и выводит сообщение `"ConcreteHandlerC: Обработано запросом C."`.

Если передать несуществующий запрос, например `handlerA.handleRequest('D')`, ни один обработчик не сможет обработать его, и будет выведено сообщение "Запрос не может быть обработан.".

Таким образом, паттерн `Chain of Responsibility` позволяет динамически определить, какой объект будет обрабатывать запрос, и обеспечивает гибкость в добавлении, изменении и управлении обработчиками.

## 1.2. Abstract Factory
Паттерн **Abstract Factory** (Абстрактная фабрика) на TypeScript предоставляет интерфейс для создания семейств связанных или взаимосвязанных объектов без привязки к их конкретным классам.

```ts
// Абстрактный класс, представляющий продукт A
abstract class AbstractProductA {
  public abstract methodA(): void;
}

// Абстрактный класс, представляющий продукт B
abstract class AbstractProductB {
  public abstract methodB(): void;
}

// Конкретный класс продукта A1
class ProductA1 extends AbstractProductA {
  public methodA(): void {
    console.log('ProductA1: Вызван метод A.');
  }
}

// Конкретный класс продукта A2
class ProductA2 extends AbstractProductA {
  public methodA(): void {
    console.log('ProductA2: Вызван метод A.');
  }
}

// Конкретный класс продукта B1
class ProductB1 extends AbstractProductB {
  public methodB(): void {
    console.log('ProductB1: Вызван метод B.');
  }
}

// Конкретный класс продукта B2
class ProductB2 extends AbstractProductB {
  public methodB(): void {
    console.log('ProductB2: Вызван метод B.');
  }
}

// Абстрактная фабрика, определяющая методы для создания продуктов A и B
abstract class AbstractFactory {
  public abstract createProductA(): AbstractProductA;
  public abstract createProductB(): AbstractProductB;
}

// Конкретная фабрика 1, реализующая методы создания продуктов A и B
class ConcreteFactory1 extends AbstractFactory {
  public createProductA(): AbstractProductA {
    return new ProductA1();
  }

  public createProductB(): AbstractProductB {
    return new ProductB1();
  }
}

// Конкретная фабрика 2, реализующая методы создания продуктов A и B
class ConcreteFactory2 extends AbstractFactory {
  public createProductA(): AbstractProductA {
    return new ProductA2();
  }

  public createProductB(): AbstractProductB {
    return new ProductB2();
  }
}

// Пример использования
const factory1: AbstractFactory = new ConcreteFactory1();
const productA1: AbstractProductA = factory1.createProductA();
const productB1: AbstractProductB = factory1.createProductB();

productA1.methodA(); // Вывод: ProductA1: Вызван метод A.
productB1.methodB(); // Вывод: ProductB1: Вызван метод B.

const factory2: AbstractFactory = new ConcreteFactory2();
const productA2: AbstractProductA = factory2.createProductA();
const productB2: AbstractProductB = factory2.createProductB();

productA2.methodA(); // Вывод: ProductA2: Вызван метод A.
productB2.methodB(); // Вывод: ProductB2: Вызван метод B.
```

В этом примере у нас есть иерархия абстрактных классов `AbstractProductA` и `AbstractProductB`, представляющих продукты `A` и `B` соответственно. Классы `ProductA1`, `ProductA2`, `ProductB1` и `ProductB2` являются конкретными реализациями продуктов.

Абстрактный класс `AbstractFactory` определяет методы `createProductA()` и `createProductB()`, которые возвращают абстрактные продукты `A` и `B` соответственно.

Конкретные классы `ConcreteFactory1` и `ConcreteFactory2` реализуют методы создания продуктов `A` и `B` в соответствии с конкретными реализациями продуктов.

В примере мы создаем объект `factory1` с типом `AbstractFactory` и вызываем его методы `createProductA()` и `createProductB()`, чтобы получить конкретные продукты `A` и `B`. Затем вызываем методы `methodA()` и `methodB()` для каждого продукта.

Аналогично, мы создаем объект `factory2` с типом `AbstractFactory` и получаем конкретные продукты `A` и `B`, а затем вызываем их методы.

Таким образом, паттерн `Abstract Factory` позволяет создавать семейства взаимосвязанных объектов без привязки к их конкретным классам, обеспечивая гибкость и удобство замены конкретных реализаций продуктов.

## 1.3. Strategy
Паттерн **Strategy** (Стратегия) на TypeScript позволяет определить семейство алгоритмов, инкапсулировать каждый из них и делать их взаимозаменяемыми.

```ts
// Интерфейс стратегии
interface Strategy {
  execute(data: string[]): void;
}

// Конкретная стратегия 1
class ConcreteStrategy1 implements Strategy {
  public execute(data: string[]): void {
    console.log("Выполнение стратегии 1:");
    data.forEach((item) => {
      console.log("- " + item.toUpperCase());
    });
    console.log("--------------");
  }
}

// Конкретная стратегия 2
class ConcreteStrategy2 implements Strategy {
  public execute(data: string[]): void {
    console.log("Выполнение стратегии 2:");
    data.forEach((item) => {
      console.log("- " + item.toLowerCase());
    });
    console.log("--------------");
  }
}

// Контекст, использующий стратегии
class Context {
  private strategy: Strategy;

  public setStrategy(strategy: Strategy): void {
    this.strategy = strategy;
  }

  public executeStrategy(data: string[]): void {
    if (this.strategy) {
      this.strategy.execute(data);
    }
  }
}

// Пример использования
const context = new Context();

// Использование стратегии 1
const strategy1 = new ConcreteStrategy1();
context.setStrategy(strategy1);
context.executeStrategy(["Apple", "Banana", "Orange"]);

// Использование стратегии 2
const strategy2 = new ConcreteStrategy2();
context.setStrategy(strategy2);
context.executeStrategy(["Apple", "Banana", "Orange"]);
```

В этом примере у нас есть интерфейс `Strategy`, который определяет метод `execute()` для выполнения стратегии.

Классы `ConcreteStrategy1` и `ConcreteStrategy2` представляют конкретные стратегии и реализуют метод `execute()`, выполняющий соответствующие алгоритмы. В данном случае, стратегия 1 преобразует элементы массива к верхнему регистру, а стратегия 2 к нижнему регистру.

Класс `Context` представляет контекст, который использует стратегии. Он имеет методы `setStrategy()` для установки стратегии и `executeStrategy()` для выполнения выбранной стратегии.

В примере мы создаем объект `context` и устанавливаем стратегию 1 с помощью метода `setStrategy()`. Затем вызываем метод `executeStrategy()` с массивом данных, который передается в соответствующую стратегию. В данном случае, выводятся элементы массива в верхнем регистре.

Затем мы меняем стратегию, устанавливая стратегию 2, и повторно вызываем метод `executeStrategy()`. Теперь элементы массива выводятся в нижнем регистре.

Таким образом, паттерн Strategy позволяет выбирать и использовать различные стратегии в зависимости от контекста, обеспечивая гибкость и удобство замены алгоритмов.

## 1.4. Decorator
Паттерн **Decorator** (Декоратор) на TypeScript позволяет динамически добавлять новую функциональность объектам путем оборачивания их в другие объекты-декораторы. 

```ts
// Интерфейс компонента
interface Component {
  operation(): void;
}

// Конкретный компонент
class ConcreteComponent implements Component {
  public operation(): void {
    console.log("Выполнение операции в конкретном компоненте.");
  }
}

// Абстрактный декоратор
abstract class Decorator implements Component {
  protected component: Component;

  constructor(component: Component) {
    this.component = component;
  }

  public operation(): void {
    this.component.operation();
  }
}

// Конкретный декоратор 1
class ConcreteDecorator1 extends Decorator {
  public operation(): void {
    super.operation();
    this.additionalOperation();
  }

  private additionalOperation(): void {
    console.log("Выполнение дополнительной операции в декораторе 1.");
  }
}

// Конкретный декоратор 2
class ConcreteDecorator2 extends Decorator {
  public operation(): void {
    super.operation();
    this.additionalOperation();
  }

  private additionalOperation(): void {
    console.log("Выполнение дополнительной операции в декораторе 2.");
  }
}

// Пример использования
const component: Component = new ConcreteComponent();

// Декорирование компонента с помощью декоратора 1
const decorator1: Component = new ConcreteDecorator1(component);
decorator1.operation();
console.log("--------------");

// Декорирование компонента с помощью декоратора 2
const decorator2: Component = new ConcreteDecorator2(component);
decorator2.operation();
console.log("--------------");

// Декорирование компонента с помощью обоих декораторов
const decorator1And2: Component = new ConcreteDecorator2(
  new ConcreteDecorator1(component)
);
decorator1And2.operation();
```

В этом примере у нас есть интерфейс `Component`, который определяет метод `operation()` для компонента.

Класс `ConcreteComponent` представляет конкретный компонент, который реализует метод `operation()`.

Абстрактный класс `Decorator` представляет абстрактный декоратор и имеет ссылку на компонент. Он также реализует метод `operation()`, который вызывает метод `operation()` у компонента.

Конкретные классы `ConcreteDecorator1` и `ConcreteDecorator2` представляют конкретные декораторы. Они расширяют абстрактный декоратор и добавляют свою дополнительную функциональность путем переопределения метода `operation()` и вызова метода `additionalOperation()`.

В примере мы создаем объект component с типом Component, который представляет конкретный компонент.

Затем мы создаем декораторы и оборачиваем компонент в декораторы, добавляя дополнительную функциональность. Декоратор 1 выполняет свою дополнительную операцию перед вызовом метода компонента, а декоратор 2 выполняет свою дополнительную операцию после вызова метода компонента.

Мы также можем комбинировать декораторы, оборачивая один декоратор в другой.

Таким образом, паттерн Decorator позволяет динамически добавлять новую функциональность объектам, обертывая их в декораторы, что позволяет гибко расширять функциональность объектов без необходимости изменять их основной код.

# Senior
# 1. Паттерны:
## 1.1. Mediator

Паттерн Mediator (Посредник) является поведенческим паттерном проектирования, который позволяет установить взаимодействие между объектами через централизованный посредник, вместо того чтобы объекты общались напрямую друг с другом. Это помогает уменьшить связанность между объектами и способствует лучшей расширяемости и поддерживаемости кода.

Пример на TypeScript:

```typescript
// Абстрактный класс посредника
abstract class Mediator {
  abstract notify(sender: Colleague, event: string): void;
}

// Конкретный класс посредника
class ConcreteMediator extends Mediator {
  private colleague1: Colleague1;
  private colleague2: Colleague2;

  setColleague1(colleague: Colleague1): void {
    this.colleague1 = colleague;
  }

  setColleague2(colleague: Colleague2): void {
    this.colleague2 = colleague;
  }

  notify(sender: Colleague, event: string): void {
    if (sender === this.colleague1) {
      console.log('Событие "' + event + '" обработано посредником у Colleague2');
      this.colleague2.operation();
    } else if (sender === this.colleague2) {
      console.log('Событие "' + event + '" обработано посредником у Colleague1');
      this.colleague1.operation();
    }
  }
}

// Абстрактный класс коллеги
abstract class Colleague {
  protected mediator: Mediator;

  constructor(mediator: Mediator) {
    this.mediator = mediator;
  }

  abstract operation(): void;
}

// Конкретный класс коллеги 1
class Colleague1 extends Colleague {
  operation(): void {
    console.log('Выполняется операция у Colleague1');
    this.mediator.notify(this, 'event1');
  }
}

// Конкретный класс коллеги 2
class Colleague2 extends Colleague {
  operation(): void {
    console.log('Выполняется операция у Colleague2');
    this.mediator.notify(this, 'event2');
  }
}

// Использование
const mediator = new ConcreteMediator();

const colleague1 = new Colleague1(mediator);
const colleague2 = new Colleague2(mediator);

mediator.setColleague1(colleague1);
mediator.setColleague2(colleague2);

colleague1.operation();
```

В этом примере у нас есть посредник `ConcreteMediator`, который устанавливает взаимодействие между коллегами `Colleague1` и `Colleague2`. Когда коллеги вызывают операцию, они уведомляют посредника, и посредник решает, как обрабатывать событие и взаимодействовать с другими коллегами. Паттерн Mediator позволяет избежать прямых зависимостей между коллегами и делает код более гибким и расширяемым.

## 1.2. Composite

Паттерн Composite (Компоновщик) является структурным паттерном проектирования, который позволяет обрабатывать отдельные объекты и группы объектов одним и тем же образом. Он позволяет создавать иерархические структуры объектов, которые могут быть обращены как единое целое.

Пример на TypeScript:

```typescript
// Абстрактный класс компонента
abstract class Component {
  protected name: string;

  constructor(name: string) {
    this.name = name;
  }

  abstract operation(): void;
  abstract add(component: Component): void;
  abstract remove(component: Component): void;
  abstract getChild(index: number): Component | null;
}

// Конкретный класс листа
class Leaf extends Component {
  operation(): void {
    console.log(`Выполняется операция у листа ${this.name}`);
  }

  add(component: Component): void {
    // Не применимо к листу
  }

  remove(component: Component): void {
    // Не применимо к листу
  }

  getChild(index: number): Component | null {
    // Не применимо к листу
    return null;
  }
}

// Конкретный класс составного компонента
class Composite extends Component {
  private children: Component[] = [];

  operation(): void {
    console.log(`Выполняется операция у составного компонента ${this.name}`);
    for (const child of this.children) {
      child.operation();
    }
  }

  add(component: Component): void {
    this.children.push(component);
  }

  remove(component: Component): void {
    const index = this.children.indexOf(component);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }

  getChild(index: number): Component | null {
    if (index >= 0 && index < this.children.length) {
      return this.children[index];
    }
    return null;
  }
}

// Использование
const root = new Composite('root');

const leaf1 = new Leaf('leaf1');
const leaf2 = new Leaf('leaf2');

const composite1 = new Composite('composite1');
const leaf3 = new Leaf('leaf3');
const leaf4 = new Leaf('leaf4');

root.add(leaf1);
root.add(leaf2);
root.add(composite1);

composite1.add(leaf3);
composite1.add(leaf4);

root.operation();
```

В этом примере у нас есть абстрактный класс `Component`, представляющий как листовые элементы (класс `Leaf`), так и составные компоненты (класс `Composite`). Компоновщик позволяет нам добавлять, удалять и получать дочерние элементы как у листовых элементов, так и у составных компонентов. При вызове операции `operation()` у корневого компонента, операция рекурсивно выполняется и для всех его дочерних элементов, включая вложенные составные компоненты.

Паттерн Composite полезен, когда необходимо работать со cтруктурированными деревьями объектов, где объекты могут быть однотипными или разнотипными. Вот некоторые области применения паттерна Composite:

1. **Графические пользовательские интерфейсы**: Composite позволяет создавать иерархические структуры пользовательских интерфейсов, где компоненты могут быть отдельными элементами интерфейса или контейнерами для других компонентов.

2. **Управление файловой системой**: Composite может использоваться для представления файловой системы, где как файлы, так и папки могут быть компонентами. Это позволяет применять одинаковые операции для работы с файлами и папками, обеспечивая единообразный интерфейс.

3. **Организация структуры документа**: Composite может быть применен для организации иерархической структуры документа, где элементы документа могут быть как отдельными блоками, так и контейнерами для других элементов.

4. **Управление иерархическими данными**: Composite может использоваться для представления иерархических данных, таких как организационные структуры, деревья категорий или иерархии продуктов.

5. **Компоновка графических объектов**: Composite может быть применен для компоновки графических объектов, таких как фигуры, элементы дизайна или элементы сцены. Он позволяет группировать объекты в иерархическую структуру и управлять ими единообразно.

Помните, что применимость паттерна Composite зависит от конкретной задачи и контекста. Паттерн Composite обеспечивает гибкость и расширяемость, позволяя работать с иерархическими структурами объектов, обращаясь к ним единообразно.

## 1.3. Memento

Паттерн Memento (Снимок) является поведенческим паттерном проектирования, который позволяет сохранять и восстанавливать внутреннее состояние объекта без нарушения инкапсуляции. Он позволяет сохранять состояние объекта в определенный момент времени и восстанавливать его позже при необходимости.

Основные участники паттерна Memento:

1. **Originator (Создатель)**: Это объект, состояние которого нужно сохранять и восстанавливать. Он имеет методы для сохранения своего состояния в Memento и восстановления состояния из Memento.

2. **Memento (Снимок)**: Это объект, который хранит сохраненное состояние Originator. Он предоставляет доступ к сохраненному состоянию только Originator'у.

3. **Caretaker (Опекун)**: Это объект, который отвечает за сохранение и управление Memento. Он может запрашивать сохранение состояния у Originator или передавать Memento для восстановления состояния Originator.

Пример на TypeScript:

```typescript
// Originator (Создатель)
class Editor {
  private text: string;

  setText(text: string): void {
    this.text = text;
  }

  getText(): string {
    return this.text;
  }

  createMemento(): Memento {
    return new Memento(this.text);
  }

  restoreMemento(memento: Memento): void {
    this.text = memento.getState();
  }
}

// Memento (Снимок)
class Memento {
  private state: string;

  constructor(state: string) {
    this.state = state;
  }

  getState(): string {
    return this.state;
  }
}

// Caretaker (Опекун)
class History {
  private mementos: Memento[] = [];

  push(memento: Memento): void {
    this.mementos.push(memento);
  }

  pop(): Memento | undefined {
    return this.mementos.pop();
  }
}

// Использование
const editor = new Editor();
const history = new History();

editor.setText('Hello, World!');
history.push(editor.createMemento());

editor.setText('Updated text');
history.push(editor.createMemento());

console.log(editor.getText()); // Output: Updated text

const memento = history.pop();
if (memento) {
  editor.restoreMemento(memento);
}

console.log(editor.getText()); // Output: Hello, World!
```

В этом примере у нас есть класс `Editor`, который имеет внутреннее состояние `text`. Мы можем сохранять состояние `Editor` с помощью метода `createMemento()`, который создает объект `Memento` с текущим состоянием `text`. Затем мы можем восстанавливать состояние `Editor` из сохраненного `Memento` с помощью метода `restoreMemento()`. Класс `History` служит в качестве опекуна и хранит историю сохраненных состояний `Editor`.

# 2. Dependency Injection

Dependency Injection (DI), или внедрение зависимостей, является паттерном программирования, который используется для управления зависимостями между объектами. Он позволяет создавать объекты, не являясь ответственными за создание или поиск зависимостей, а вместо этого получать их извне.

В основе DI лежит принцип инверсии управления (Inversion of Control - IoC), который заключается в том, что объекты не создают свои зависимости самостоятельно, а требуют их из внешнего источника. Это делает код более гибким, расширяемым и легко тестируемым.

Существует несколько способов реализации DI:

1. **Конструкторная внедрение зависимостей (Constructor Injection)**: Зависимости передаются через конструктор объекта.

```typescript
class UserService {
  private readonly userRepository: UserRepository;

  constructor(userRepository: UserRepository) {
    this.userRepository = userRepository;
  }

  // ...
}
```

2. **Внедрение зависимостей через сеттеры (Setter Injection)**: Зависимости устанавливаются через методы-сеттеры.

```typescript
class UserService {
  private userRepository: UserRepository;

  setUserRepository(userRepository: UserRepository) {
    this.userRepository = userRepository;
  }

  // ...
}
```

3. **Внедрение зависимостей через интерфейс (Interface Injection)**: Объект получает зависимости через методы, определенные в интерфейсе.

```typescript
interface UserRepositoryInjectable {
  setUserRepository(userRepository: UserRepository): void;
}

class UserService implements UserRepositoryInjectable {
  private userRepository: UserRepository;

  setUserRepository(userRepository: UserRepository) {
    this.userRepository = userRepository;
  }

  // ...
}
```

Преимущества Dependency Injection:

- Упрощает тестирование, так как зависимости могут быть заменены на моки или заглушки.
- Улучшает читаемость кода, так как зависимости становятся явно объявленными.
- Повышает гибкость и переиспользуемость кода, так как зависимости могут быть легко заменены или изменены без изменения самого объекта.
- Облегчает разделение ответственности между классами, так как каждый класс сосредоточен на своей основной функциональности, а не на создании зависимостей.

Dependency Injection является важной практикой в разработке программного обеспечения, которая способствует созданию более гибкого и тестируемого кода, улучшает его качество и облегчает его поддержку.
