# Junior 
# 1. JS - однопоточный и синхронный язык

JavaScript - это однопоточный и синхронный язык программирования, который означает, что он работает только в одном потоке выполнения. Это означает, что JavaScript выполняет код последовательно, по одному оператору за раз.

Если приложение блокирует поток выполнения, то пользовательский интерфейс перестает реагировать и приложение кажется зависшим. Поэтому важно писать асинхронный код, чтобы не блокировать поток выполнения и не создавать подобных проблем.

Вместо многопоточности JavaScript использует событийную модель, основанную на очереди событий (event queue) и цикле событий (event loop). Это позволяет обрабатывать события асинхронно, не блокируя поток выполнения.

Событийная модель JavaScript позволяет реагировать на события пользователя (например, щелчки мыши или нажатия клавиш) и выполнение асинхронных операций (например, загрузка данных с сервера) в фоновом режиме. Вся асинхронная обработка в JavaScript основывается на колбэках (callback) и промисах (promise).

# Junior+
# 1. XMLHttpRequest, fetch

XMLHttpRequest и fetch - это два API для выполнения асинхронных HTTP-запросов в JavaScript.

XMLHttpRequest был первоначально создан для выполнения AJAX-запросов на сервер. Он позволяет отправлять запросы на сервер и получать ответы в форматах JSON, XML, HTML или текстовом формате. XMLHttpRequest можно использовать для выполнения запросов GET, POST, PUT и DELETE.

Пример использования XMLHttpRequest для выполнения GET-запроса:

```ts
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://example.com/data');
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(xhr.responseText);
  }
}
xhr.send();
```

Fetch является более современным API, предназначенным для выполнения HTTP-запросов. Он также поддерживает выполнение запросов в различных форматах и методах. Fetch API имеет более удобный синтаксис и возвращает Promise, что делает его более удобным для работы с асинхронными запросами.

Пример использования Fetch API для выполнения GET-запроса:

```ts
fetch('https://example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

В целом, использование Fetch API является более предпочтительным, чем использование XMLHttpRequest, благодаря его удобному синтаксису и поддержке Promise. Однако, в некоторых сценариях, использование XMLHttpRequest может быть более подходящим, например, если требуется выполнить запрос в синхронном режиме.

# Middle
# 1. Механизм Event loop
Идея **событийного цикла** очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.

Главная задача циклов событий — следить за стеком и очередью задач. Если стек пуст, цикл берет первый элемент из очереди, помещает его в стек и выполняет.

### Общий алгоритм движка:

1. Пока есть задачи - выполнить их, начиная с самой старой
2. Бездействовать до появления новой задачи, а затем перейти к пункту 1

### Примеры задач:

1. Когда загружается внешний скрипт, то задача – это выполнение этого скрипта.
2. Когда пользователь двигает мышь, задача – сгенерировать событие mousemove и выполнить его обработчики.
3. Когда истечёт таймер, установленный с помощью setTimeout(func, ...), задача – это выполнение функции func
4. И так далее.

# 2. Как работают таски / микротаски
## 2.1 Макротаски
это браузерные события, такие как setTimeout, onclick, mousemove и т.д.

## 2.2 Микрозадачи
приходят только из кода. Обычно они создаются промисами: выполнение обработчика **.then/catch/finally** становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.

Также есть специальная функция **queueMicrotask(func)**, которая помещает func в очередь микрозадач.

**Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.**

# 3. Как используются:
## 3.1 Callback
```ts
document.getElementById('button').addEventListener('click', () => {
  // item clicked
})
```

## 3.2 Promise
```ts
let done = true
const isItDoneYet = new Promise(
  (resolve, reject) => {
    if (done) { 
      const workDone = 'Here is the thing I built'
      resolve(workDone)
    } else {
      const why = 'Still working on something else'
      reject(why)
    }
  }
)
```

# Middle+
# 1. Callbackhell, методы борьбы с ним

Callback hell (иногда называемый также pyramid of doom) - это негативный эффект, который возникает, когда большое количество асинхронных операций выполняются вложенно друг в друга внутри callback-функций. Это приводит к созданию нечитаемого и сложного для понимания кода, а также может привести к возникновению ошибок и затруднить отладку.

Классический пример callback hell может выглядеть так:

```ts
getUserData(userId, function(user) {
  getUserPosts(user.id, function(posts) {
    getPostComments(posts[0].id, function(comments) {
      displayUserData(user);
      displayPosts(posts);
      displayComments(comments);
    });
  });
});
```

Здесь мы вызываем несколько асинхронных функций, которые зависят друг от друга. В результате вложенность колбеков усложняется, и код становится трудным для чтения и поддержки.


**Существует несколько методов, которые помогают бороться с callback hell**:

1. Использование промисов - это объекты, которые представляют результат асинхронной операции. Промисы позволяют упростить обработку асинхронных операций и избежать глубокой вложенности callback-функций. 

Пример использования промисов:

```ts
function loadData(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = () => resolve(xhr.responseText);
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}

loadData('https://example.com/data')
  .then(data => {
    // обработка данных
  })
  .catch(error => {
    // обработка ошибки
  });
```

2. Использование async/await - это синтаксический сахар над промисами, который позволяет писать асинхронный код так, как будто он синхронный. Это также упрощает обработку асинхронных операций и избежать глубокой вложенности callback-функций. 

Пример использования async/await:

```ts
async function loadData(url) {
  try {
    const response = await fetch(url);
    const data = await response.json();
    // обработка данных
  } catch (error) {
    // обработка ошибки
  }
}

loadData('https://example.com/data');
```

3. Использование библиотек и фреймворков - такие библиотеки, как Async.js или Bluebird, предоставляют много инструментов для управления асинхронным кодом и борьбы с callback hell.

4. Разбиение функций на более мелкие функции - это помогает уменьшить глубину вложенности и сделать код более понятным.


# 2. Async / await

Async/await - это механизм работы с асинхронным кодом в JavaScript, который упрощает синтаксис и делает код более читабельным.

Он основан на использовании промисов, которые представляют собой обещания выполнения операции, и позволяет асинхронному коду выглядеть как синхронный.

Синтаксис async/await состоит из двух ключевых слов - async и await.

Ключевое слово async используется для обозначения функции, которая содержит асинхронный код. Внутри функции можно использовать ключевое слово await для ожидания выполнения промиса и получения его результата.

Пример использования async/await:

```ts
async function fetchUsers() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchUsers();
```

В этом примере мы создаем асинхронную функцию fetchUsers, которая использует ключевое слово await для ожидания выполнения запроса на сервер с помощью функции fetch. Затем мы используем await для получения данных из ответа в формате JSON.

Ключевое слово try/catch используется для обработки ошибок, которые могут возникнуть при выполнении асинхронной операции.

Async/await является более простым и понятным способом работы с асинхронным кодом в JavaScript по сравнению с callback-функциями и promise-объектами.

# Senior
# 1. Особенности обработки цепочки callback-ов Promis-а после отлавливания ошибки
Цепочки промисов отлично подходят для перехвата ошибок. Если промис завершается с ошибкой, то управление переходит в ближайший обработчик ошибок. На практике это очень удобно.

Например, в представленном ниже примере для fetch указана неправильная ссылка (сайт не существует), и .catch перехватывает ошибку:
```ts
fetch('https://no-such-server.blabla') // ошибка
  .then(response => response.json())
  .catch(err => alert(err)) // TypeError: failed to fetch
```

Как видно, **.catch** не обязательно должен быть сразу после ошибки, он может быть далее, после одного или даже нескольких **.then**

Или, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON. Самый лёгкий путь перехватить все ошибки – это добавить .catch в конец цепочки:
```ts
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise((resolve, reject) => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
  .catch(error => alert(error.message));
```
Если все в порядке, то такой **.catch** вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.

## Неявный try…catch
Вокруг функции промиса и обработчиков находится "невидимый try..catch". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.

Например, этот код:
```ts
new Promise((resolve, reject) => {
  throw new Error("Ошибка!");
}).catch(alert); // Error: Ошибка!
…Работает так же, как и этот:

new Promise((resolve, reject) => {
  reject(new Error("Ошибка!"));
}).catch(alert); // Error: Ошибка!
```

**"Невидимый try..catch"** вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.

Это работает не только в функции промиса, но и в обработчиках. Если мы бросим ошибку (**throw**) из обработчика (**.then**), то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.

Пример:
```ts
new Promise((resolve, reject) => {
  resolve("ок");
}).then((result) => {
  throw new Error("Ошибка!"); // генерируем ошибку
}).catch(alert); // Error: Ошибка!
```
Это происходит для всех ошибок, не только для тех, которые вызваны оператором **throw**. Например, программная ошибка:
```ts
new Promise((resolve, reject) => {
  resolve("ок");
}).then((result) => {
  blabla(); // нет такой функции
}).catch(alert); // ReferenceError: blabla is not defined
```

Финальный **.catch** перехватывает как промисы, в которых вызван **reject**, так и случайные ошибки в обработчиках.


## Пробрасывание ошибок

Как мы уже заметили, **.catch** ведёт себя как **try..catch**. Мы можем иметь столько обработчиков **.then**, сколько мы хотим, и затем использовать один **.catch** в конце, чтобы перехватить ошибки из всех обработчиков.

В обычном **try..catch** мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.

Если мы пробросим (**throw**) ошибку внутри блока **.catch**, то управление перейдёт к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик **.then**.

В примере ниже **.catch** успешно обрабатывает ошибку:
```ts
// the execution: catch -> then
new Promise((resolve, reject) => {

  throw new Error("Ошибка!");

}).catch(function(error) {

  alert("Ошибка обработана, продолжить работу");

}).then(() => alert("Управление перейдёт в следующий then"));
```

Здесь блок **.catch** завершается нормально. Поэтому вызывается следующий успешный обработчик **.then**.

В примере ниже мы видим другую ситуацию с блоком **.catch**. Обработчик (*) перехватывает ошибку и не может обработать её (например, он знает как обработать только URIError), поэтому ошибка пробрасывается далее:
```ts
// the execution: catch -> catch -> then
new Promise((resolve, reject) => {

  throw new Error("Ошибка!");

}).catch(function(error) { // (*)

  if (error instanceof URIError) {
    // обрабатываем ошибку
  } else {
    alert("Не могу обработать ошибку");

    throw error; // пробрасывает эту или другую ошибку в следующий catch
  }

}).then(function() {
  /* не выполнится */
}).catch(error => { // (**)

  alert(`Неизвестная ошибка: ${error}`);
  // ничего не возвращаем => выполнение продолжается в нормальном режиме

});
```

Управление переходит от первого блока **.catch** (*) к следующему (**), вниз по цепочке.


## Необработанные ошибки

Что произойдёт, если ошибка не будет обработана? Например, мы просто забыли добавить **.catch** в конец цепочки, как здесь:
```ts
new Promise(function() {
  noSuchFunction(); // Ошибка (нет такой функции)
})
  .then(() => {
    // обработчики .then, один или более
  }); // без .catch в самом конце!
```

В случае ошибки выполнение должно перейти к ближайшему обработчику ошибок. Но в примере выше нет никакого обработчика. Поэтому ошибка как бы «застревает», её некому обработать.

На практике, как и при обычных необработанных ошибках в коде, это означает, что что-то пошло сильно не так.

Что происходит, когда обычная ошибка не перехвачена **try..catch**? Скрипт умирает с сообщением в консоли. Похожее происходит и в случае необработанной ошибки промиса.

JavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку. Вы можете увидеть её в консоли, если запустите пример выше.

В браузере мы можем поймать такие ошибки, используя событие **unhandledrejection**:
```ts
window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});

new Promise(function() {
  throw new Error("Ошибка!");
}); // нет обработчика ошибок
```

Это событие является частью стандарта HTML.

Если происходит ошибка, и отсутствует её обработчик, то генерируется событие unhandledrejection, и соответствующий объект event содержит информацию об ошибке.

Обычно такие ошибки неустранимы, поэтому лучше всего – информировать пользователя о проблеме и, возможно, отправить информацию об ошибке на сервер.

