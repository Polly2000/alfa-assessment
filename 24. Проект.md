# Junior
# 1. Что такое Webpack

Webpack - это популярный инструмент для сборки JavaScript-приложений. Он является модульным бандлером, который позволяет объединять различные модули и зависимости вашего проекта в один или несколько бандлов (bundle) для браузера.

**Основные возможности Webpack:**
1. **Модульность:** Webpack позволяет организовать код в модули, что делает разработку приложений более структурированной и управляемой. Вы можете импортировать и экспортировать модули JavaScript, а также другие типы файлов, такие как CSS и изображения.

2. **Обработка зависимостей:** Webpack автоматически анализирует зависимости между модулями и создает граф зависимостей. Это позволяет эффективно управлять зависимостями и объединять их в один или несколько бандлов, минимизируя количество запросов к серверу и улучшая производительность приложения.

3. **Поддержка различных типов файлов:** Webpack поддерживает не только JavaScript, но и другие типы файлов, такие как CSS, изображения, шрифты и т. д. Это позволяет легко интегрировать различные технологии и инструменты в проект.

4. **Широкие возможности настройки и расширения:** Webpack обладает гибкой конфигурацией, которая позволяет настроить его под нужды проекта. Вы можете использовать различные загрузчики и плагины для обработки файлов, оптимизации кода, преобразования и других задач.

5. **Эффективная оптимизация и минимизация кода:** Webpack предоставляет мощные возможности для оптимизации и минимизации кода. Он может сжимать и объединять файлы, применять различные оптимизации и трансформации, а также генерировать итоговый оптимизированный код для продакшн-среды.

6. **Активное сообщество и экосистема:** Webpack имеет широкое и активное сообщество разработчиков, которые создают плагины, загрузчики и инструменты для расширения функциональности Webpack. Это позволяет находить готовые решения и обмениваться опытом с другими разработчиками.

В целом, Webpack предоставляет мощные возможности для сборки и управления зависимостями веб-приложений, что делает его предпочтительным инструментом для многих разработчиков.

# Junior+
# 1. Как работает конфигурация Webpack

Конфигурация Webpack представляет собой JavaScript-файл, в котором определяются настройки и параметры сборки проекта. Когда вы запускаете Webpack, он загружает этот конфигурационный файл и использует его для определения того, как собирать и обрабатывать ваши файлы.

**Вот общий принцип работы конфигурации Webpack:**

1. **Определение точки входа (entry point):** В конфигурации Webpack вы указываете точку входа вашего приложения. Точка входа обычно представляет собой главный файл JavaScript, с которого начинается загрузка и сборка остальных модулей и зависимостей.

2. **Определение правил (rules):** В конфигурации вы определяете правила (rules) для обработки различных типов файлов. Например, вы можете указать, что файлы JavaScript должны быть обработаны с помощью загрузчика Babel для поддержки современного синтаксиса или что файлы CSS должны быть обработаны с помощью загрузчиков и плагинов для объединения, минимизации и добавления префиксов.

3. **Определение плагинов (plugins):** Плагины предоставляют дополнительные возможности и функциональность во время сборки. Вы можете использовать плагины для оптимизации кода, генерации HTML-страниц, копирования файлов, определения глобальных переменных и т. д. В конфигурации Webpack вы указываете, какие плагины должны быть подключены и настроены.

4. **Определение настроек вывода (output):** В конфигурации Webpack вы указываете настройки вывода, которые определяют, где и каким образом собранные файлы будут сохраняться. Например, вы можете указать папку назначения, имя собранного файла, формат вывода и другие параметры.

5. **Дополнительные настройки и оптимизации:** Конфигурация Webpack также позволяет определить дополнительные настройки и оптимизации, такие как режим сборки (development или production), оптимизация размера собранного кода, использование source maps для отладки, настройка dev-сервера и другие параметры.

Когда вы запускаете сборку с помощью команды webpack или другого инструмента, Webpack загружает вашу конфигурацию и начинает обрабатывать файлы в соответствии с указанными правилами и настройками. Он анализирует зависимости модулей, объединяет их, применяет загрузчики и плагины, и создает итоговые сборки файлов, готовые к развертыванию или использованию в вашем приложении.

# 2. прекоммитные проверки

**Прекоммитные проверки (pre-commit checks)** - это набор автоматических проверок, которые выполняются перед фиксацией (коммитом) изменений в репозитории версионного контроля. Цель прекоммитных проверок состоит в том, чтобы обнаружить потенциальные проблемы или ошибки на ранней стадии разработки, чтобы предотвратить попадание некорректного или неполного кода в основную ветку проекта. Это помогает поддерживать качество кода, согласованность стиля, улучшает процесс разработки и обеспечивает более надежные и стабильные релизы.

**Прекоммитные проверки могут включать в себя следующие действия:**

1. **Проверка стиля кодирования:** Может быть использован линтер (например, ESLint для JavaScript или Pylint для Python) для проверки соответствия кода определенным стандартам форматирования и стилю.

2. **Проверка типов данных:** Если проект использует статическую типизацию (например, TypeScript или Flow), то можно выполнить проверку типов данных, чтобы обнаружить возможные ошибки в типах переменных и параметров функций.

3. **Запуск тестов:** Прекоммитные проверки могут включать выполнение набора автоматических тестов, чтобы убедиться, что изменения не вызывают сбоев или ошибок в существующей функциональности.

4. **Проверка синтаксиса и семантики:** Можно использовать инструменты, такие как компиляторы или статические анализаторы кода, для проверки синтаксических ошибок и потенциальных проблем семантики кода.

5. **Проверка зависимостей:** Можно выполнить проверку на наличие обновлений зависимостей проекта или наличие уязвимостей в используемых библиотеках.

6. **Форматирование кода:** Прекоммитные проверки могут включать автоматическое форматирование кода для соблюдения стандартов форматирования и улучшения читаемости.

В зависимости от используемых инструментов и процессов разработки, прекоммитные проверки могут быть настроены с использованием различных инструментов и сценариев, таких как Git Hooks, предварительные команды в системах сборки (например, npm scripts), CI/CD-серверы и другие инструменты автоматизации разработки.

# 3. менеджеры пакетов:
Менеджеры пакетов являются инструментами, которые помогают управлять зависимостями и установкой пакетов в различных программных проектах. Они предоставляют средства для удобной работы с пакетами, их версиями, обновлениями и удалением.
## 3.1. yarn

- Разработан Facebook'ом и Google.
- Позволяет более эффективно управлять зависимостями и обеспечивает более быструю установку пакетов.
- Использует файл yarn.lock для фиксации версий пакетов и обеспечения повторяемости установки.
- Предоставляет функцию автоматического резолвинга конфликтов зависимостей.
- Позволяет создавать и использовать локальные кэши для повторного использования пакетов на разных проектах.
- Предлагает удобный интерфейс командной строки с дополнительными функциями, такими как подсказки при вводе команд.
- Поддерживает параллельное скачивание пакетов, что ускоряет процесс установки.

## 3.2. npm

- Разработан как часть Node.js и является его официальным менеджером пакетов.
- Широко используется в экосистеме JavaScript и имеет большое количество пакетов, доступных для установки.
- Использует файл package-lock.json для фиксации версий пакетов и обеспечения повторяемости установки (начиная с версии npm 5).
- Имеет интеграцию с другими инструментами и сценариями разработки, такими как автоматическая установка пакетов при установке проекта из репозитория версионного контроля.
- Предоставляет широкий набор команд для управления пакетами, включая установку, обновление, удаление, публикацию и другие операции.

Оба менеджера пакетов имеют свои преимущества и недостатки, и выбор между ними обычно зависит от индивидуальных предпочтений, требований проекта и существующей инфраструктуры разработки.


# Middle
# 1. Зачем нужны лоадеры
1. Уведомление о процессе загрузки: Лоадеры предоставляют визуальную обратную связь пользователю о том, что приложение выполняет определенную задачу или загружает данные. Они позволяют пользователю понять, что приложение активно работает и не зависло. Это особенно полезно, если задача требует времени или имеет длительный процесс загрузки.
2. Улучшение пользовательского опыта: Лоадеры создают чувство активности и ответа от приложения, что способствует лучшему пользовательскому опыту. Вместо того, чтобы ожидать безвозвратно или видеть пустое пространство на экране, пользователь видит анимацию или индикатор загрузки, что помогает снизить чувство ожидания и улучшает восприятие работы приложения.
3. Индикация ошибок или проблем: Лоадеры также могут использоваться для сообщения о возникновении ошибки или проблемы в процессе выполнения задачи. Например, приложение может показать специальный лоадер с определенным сообщением или значком, если произошла ошибка во время загрузки данных. Это помогает пользователям понять, что что-то пошло не так и что приложение обрабатывает ситуацию.
4. Предотвращение повторных действий: Во время процесса загрузки или выполнения задачи лоадеры могут быть использованы для блокировки определенных действий пользователя, чтобы предотвратить нежелательное поведение или повторные запросы. Например, кнопка отправки формы может быть временно заблокирована с помощью лоадера, чтобы предотвратить множественные отправки формы.
# 2. Зачем нужны плагины
1. Для расширения функциональности: Плагины позволяют добавить новые функции и возможности в приложение, которые могут быть недоступны по умолчанию. Например, плагины могут предоставлять готовые компоненты интерфейса, интеграцию со сторонними сервисами или дополнительные инструменты разработки. Это позволяет быстро и удобно добавлять нужные функции без необходимости писать код с нуля.
2. Плагины обеспечивают гибкость и настраиваемость приложения. Они позволяют выбирать и включать только те функции, которые нам нужны, и настраивать их поведение в соответствии с требованиями проекта. Это делает приложение более модульным и позволяет легко вносить изменения и обновления без необходимости изменения основного кода.
3. Плагины позволяют повторно использовать код и компоненты, что экономит время и усилия разработчиков. Готовые плагины предоставляют функциональность, которую можно использовать в разных проектах без необходимости писать новый код с нуля. Кроме того, плагины часто имеют хорошую документацию и поддержку сообщества, что упрощает их использование и интеграцию в проекты.

В целом, плагины в разработке приложений являются мощным инструментом для создания более мощных, настраиваемых и эффективных приложений, а также способствуют совместному развитию и обмену опытом в сообществе разработчиков.

# 3. Семантическое версионирование
**Семантическое версионирование** (Semantic Versioning, сокращенно SemVer) - это система нумерации версий программного обеспечения, которая предоставляет стандартизированный способ указания изменений в программном коде и обеспечивает совместимость между различными версиями библиотек, пакетов и приложений.

Семантическое версионирование состоит из трех чисел, разделенных точками: "major.minor.patch". Вот их основные значения:
1. Major version (основная версия): Увеличение основной версии указывает на внесение несовместимых изменений в API или функциональность, которые могут повлиять на существующий код. Это означает, что при переходе на новую основную версию необходимо проверить и, возможно, внести изменения в свой код, чтобы он работал с новой версией.
2. Minor version (минорная версия): Увеличение минорной версии указывает на добавление новых функций или улучшений, которые обычно сохраняют обратную совместимость с предыдущими версиями. Это означает, что можно обновить до новой минорной версии без необходимости внесения значительных изменений в код, но могут появиться новые возможности для использования.
3. Patch version (версия патча): Увеличение версии патча указывает на исправление ошибок или проблем без добавления новой функциональности. Обычно обновление до новой версии патча не должно вызывать проблем совместимости и не требует значительных изменений в коде.

В дополнение к основным числам, SemVer также позволяет использовать предварительные версии (pre-release) и метаданные (metadata) для указания дополнительной информации о версии.

Семантическое версионирование помогает лучше управлять зависимостями между пакетами и библиотеками, облегчает обновление и поддержку кода, а также обеспечивает четкую коммуникацию о изменениях в программном обеспечении. Это особенно важно при работе с открытыми исходными кодами и при разработке расширяемых и модульных приложений.

# 4. Стартовые скипты в package.json
**Стартовые скрипты (start scripts) в файле package.json** используются для запуска определенных команд или скриптов в процессе разработки или запуска приложения. Они представляют собой удобный способ автоматизации повторяющихся задач.

В файле `package.json`, в секции `"scripts"`, вы можете определить различные скрипты и привязать их к соответствующим командам. Самый распространенный стартовый скрипт - `"start"`. Обычно он используется для запуска приложения или сервера разработки. Например:
```json
"scripts": {
  "start": "node server.js"
}
```

Здесь скрипт `"start"` запускает команду `"node server.js"`, которая запускает файл `"server.js"` с использованием Node.js.

Кроме `"start"`, можно определить и другие пользовательские стартовые скрипты в секции `"scripts"`. Например:
```json
"scripts": {
  "build": "webpack --mode production",
  "test": "jest"
}
```

В этом примере, скрипт `"build"` запускает команду `"webpack --mode production"` для сборки проекта в режиме продакшн, а скрипт `"test"` запускает команду `"jest"` для запуска тестов.
Можно запустить стартовый скрипт, выполнив команду `npm start` или `yarn start` в терминале, в директории, где находится файл `package.json`. Он автоматически выполнит указанную команду или скрипт.

# 5. HMR
**HMR** расшифровывается как "Hot Module Replacement" (горячая замена модулей). Это техника веб-разработки, которая позволяет вносить изменения в код приложения в режиме реального времени без перезагрузки всей страницы или перезапуска сервера.

Когда HMR активирован, изменения в коде (например, изменения в JavaScript, CSS или HTML) обнаруживаются и автоматически применяются внутри работающего приложения без перезагрузки. Новый код модуля заменяет старый, а состояние приложения сохраняется. Это позволяет разработчикам видеть изменения в режиме реального времени и тестировать их без прерывания работы приложения.

Также, в Node.js с использованием инструментов, таких как Nodemon или Webpack Dev Server, HMR позволяет автоматически перезапускать сервер при изменении исходного кода, что ускоряет процесс разработки и облегчает тестирование серверной логики.

# 6. Tree shaking
**Tree shaking** - это оптимизационная техника в сборке JavaScript-кода, которая позволяет удалять неиспользуемый код (также известный как "мёртвый код") из бандла или модуля. Это позволяет сократить размер финального бандла JavaScript, уменьшить время загрузки и улучшить производительность приложения.

Tree shaking работает путем статического анализа зависимостей модулей и идентификации кода, который не вызывается ни из каких точек входа в приложение. Компилятор или сборщик JavaScript, такой как Webpack или Rollup, использует эту информацию для удаления неиспользуемых частей кода во время сборки.

В результате, только используемый код остается в финальном бандле, что помогает уменьшить размер файлов и улучшить производительность приложения, так как меньший объем кода требует меньше времени на загрузку и выполнение. Tree shaking особенно полезен при работе с большими библиотеками или фреймворками, где множество функциональности может оставаться неиспользованным в конкретном приложении.

# 7. Минификация
**Минификация** - это процесс сокращения размера файла, удаляя все избыточные символы и пробелы, необходимые только для читаемости кода. Это одна из распространенных оптимизаций, применяемых к веб-ресурсам, таким как HTML, CSS и JavaScript.

В случае JavaScript, минификация включает в себя следующие шаги:
1. Удаление комментариев: Все комментарии, которые не влияют на выполнение кода, удаляются.
2. Удаление пробелов и переводов строк: Лишние пробелы и переводы строк удаляются, чтобы уменьшить размер файла.
3. Сокращение имен переменных и функций: Длинные имена переменных и функций заменяются на более короткие, без изменения их функциональности. Это также помогает сократить размер файла.
4. Сжатие кода: Код сжимается путем замены длинных ключевых фраз на более короткие символы. Например, true может быть заменено на !0, а false на !1.

Минификация помогает снизить размер файлов, улучшить время загрузки и снизить потребление пропускной способности сети. Однако следует отметить, что минификация делает код менее читаемым для людей, поскольку все сокращения и удаления символов направлены на оптимизацию размера файла, а не на его читабельность.


# Middle+
# 1. Разделение конфига на prod/dev
Разделение конфигурации на продакшн (prod) и разработку (dev) - это практика, которая позволяет иметь различные настройки для разных сред выполнения приложения или проекта. Это полезно, когда некоторые параметры или параметры безопасности отличаются между средами, и вы хотите управлять ими независимо.

Общие подходы к разделению конфигурации на prod и dev:
1. Раздельные файлы конфигурации: создание отдельныых файлов конфигурации для каждой среды. Например, config.prod.js для продакшн и config.dev.js для разработки. Каждый файл будет содержать настройки, специфичные для соответствующей среды.
2. Переменные окружения: Использование переменных окружения для определения текущей среды выполнения. В зависимости от значения переменной окружения,  приложение будет загружать соответствующую конфигурацию. Например, мы можем использовать переменную process.env.NODE_ENV в Node.js или process.env.REACT_APP_ENV в React приложениях.
3. Условные проверки: В коде можно использовать условные проверки, чтобы определить текущую среду выполнения и применить соответствующую конфигурацию. Например, если мы используем JavaScript, мы можем использовать условные операторы if-else или тернарные операторы.
4. Сборщики и средства сборки: Некоторые инструменты сборки, такие как Webpack или Babel, позволяют нам определять разные конфигурации в зависимости от среды выполнения. Мы можем использовать специальные плагины или параметры конфигурации, чтобы настроить среду dev и prod.

Конфигурация для среды dev может содержать дополнительные настройки для отладки, логирования и разработческих удобств, в то время как конфигурация для среды prod обычно оптимизирована для производительности и безопасности.

# 2. Bundle-analyzer
Bundle Analyzer (анализатор бандла) - это инструмент, который позволяет визуализировать и анализировать структуру и размер бандла JavaScript-приложения. Он помогает определить, какие модули и зависимости включены в бандл, и какой объем памяти они занимают.

Bundle Analyzer обычно используется в средах разработки веб-приложений, особенно с использованием инструментов сборки, таких как Webpack или Rollup. Он предоставляет графическое представление бандла, позволяя вам увидеть, какие модули и зависимости составляют основную часть размера бандла.

При использовании Bundle Analyzer можно получить информацию:
1. Размер бандла: Показывает общий размер бандла и его составляющих, таких как модули, зависимости, стили и другие ресурсы.
2. Структура зависимостей: Позволяет увидеть, какие модули зависят от других модулей, и какие зависимости занимают больше места в бандле.
3. Тепловая карта размера: Визуализирует размер каждого модуля или зависимости с помощью цветовой схемы, позволяя быстро определить, какие части бандла занимают больше места.

Анализ бандла с помощью Bundle Analyzer позволяет оптимизировать размер бандла, идентифицировать неиспользуемый код (tree shaking), разрешить проблемы дублирования зависимостей и принять другие меры для улучшения производительности и оптимизации вашего JavaScript-приложения.

# 3. HtmlWebpackPlugin
HtmlWebpackPlugin - это плагин для сборки JavaScript-приложений с использованием инструментов, таких как Webpack. Он автоматически создает файл HTML и вставляет необходимые сгенерированные скрипты и стили в этот файл.

HtmlWebpackPlugin облегчает процесс создания файла HTML, который автоматически ссылается на сгенерированные бандлы JavaScript и CSS. Он также может автоматически добавлять хеширование и кэширование к именам файлов для обновления кэша в браузере, когда код меняется.

Некоторые основные функции и возможности HtmlWebpackPlugin:
1. Создание файла HTML: Плагин генерирует файл HTML на основе шаблона, который мы предоставляем. Это может быть простой HTML-файл или файл с использованием шаблонизатора, такого как Handlebars или EJS.
2. Вставка сгенерированных ресурсов: HtmlWebpackPlugin автоматически вставляет ссылки на сгенерированные бандлы JavaScript и CSS в нашем файле HTML, учитывая зависимости, настроенные в сборке проекта.
3. Контроль кэширования: Плагин может добавить уникальные хеши или версии к именам файлов, чтобы обновить кэш в браузере при изменении кода. Это помогает предотвратить проблемы с кэшированием старых версий файлов.
4. Настройка HTML: Мы можем настроить множество параметров, таких как заголовок страницы, мета-теги, внедрение собственного контента и использование пользовательских шаблонов.
5. Множество экземпляров: Мы можем создать несколько экземпляров HtmlWebpackPlugin для создания нескольких файлов HTML с различными настройками и шаблонами.

HtmlWebpackPlugin упрощает процесс создания файлов HTML для  проектов, особенно в сочетании с инструментами сборки (Webpack). Он позволяет автоматизировать вставку сгенерированных ресурсов и облегчает управление HTML-кодом приложения.

# 4. TerserPlugin
**TerserPlugin** - это плагин для сжатия и минификации JavaScript-кода в процессе сборки приложения с использованием инструментов, таких как Webpack. Он использует Terser - популярный инструмент для сжатия и оптимизации JavaScript, основанный на UglifyJS.

TerserPlugin позволяет автоматически применять различные оптимизации к JavaScript-коду, чтобы сократить его размер и улучшить производительность приложения. 

Вот некоторые основные функции и возможности TerserPlugin:
1. Минификация: Плагин применяет процесс минификации, который включает удаление комментариев, сокращение имен переменных и функций, сжатие кода и т.д. Это позволяет сократить размер JavaScript-кода.
2. Сжатие: TerserPlugin использует различные алгоритмы сжатия, чтобы уменьшить размер кода без потери его функциональности. Это может включать удаление недостижимого кода, оптимизацию операций с числами, сокращение строк и т.д.
3. Удаление неиспользуемого кода (tree shaking): Плагин может работать совместно с другими инструментами, такими как Tree shaking, чтобы удалить неиспользуемый код из бандла. Это также помогает уменьшить размер финального файла JavaScript.

Опции конфигурации: с помощью TerserPlugin мы можем настроить уровень сжатия, определить исключения для определенных файлов или модулей, и т.д.


# Senior
# 1. Механизмы ускорения горячей/холодной сборки проекта

Для ускорения горячей/холодной сборки проекта можно использовать следующие механизмы:

1. **Инкрементальная сборка**: При инкрементальной сборке только измененные файлы или компоненты пересобираются, вместо полной пересборки всего проекта. Это сокращает время сборки, поскольку только необходимые изменения обрабатываются и компилируются.

2. **Кэширование промежуточных результатов**: Сохранение промежуточных результатов, таких как скомпилированные библиотеки, зависимости и промежуточные файлы, позволяет избежать повторной компиляции при следующей сборке. Кэширование может быть настроено на уровне сборки или инструментов сборки, таких как Babel, webpack или Gradle.

3. **Ленивая загрузка зависимостей**: Вместо загрузки и компиляции всех зависимостей проекта сразу, можно использовать механизмы ленивой загрузки, чтобы загружать и компилировать только необходимые модули по мере их использования. Это особенно полезно для проектов с большим количеством зависимостей или большим объемом кода.

4. **Многопоточная сборка**: Использование многопоточности позволяет выполнять параллельную сборку проекта, что может значительно сократить время сборки. Это особенно эффективно для проектов с большим количеством файлов или модулей.

5. **Кэширование результатов тестирования**: Если ваш проект включает тесты, вы можете кэшировать результаты предыдущих тестов и использовать их при следующей сборке. Это позволяет избежать повторного выполнения тестов, что ускоряет процесс сборки.

6. **Использование инструментов сборки и сред разработки оптимизированного производительности**: Некоторые инструменты сборки, такие как webpack или Rollup, предлагают различные оптимизации, такие как сжатие кода, удаление неиспользуемых зависимостей и разделение кода на более мелкие модули. Также, выбор оптимизированной среды разработки, которая обладает хорошей производительностью и поддерживает многопоточную сборку, также может значительно ускорить процесс сборки.

# 2. Уметь пользоваться 1-2 другими инструментами для сборки (gulp, rollup)

# 3. Понимать принцип выбора собрщика исходя из задачи
