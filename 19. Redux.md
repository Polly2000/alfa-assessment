# Junior
# 1. Redux, область применения

Redux - это библиотека для управления состоянием приложения в JavaScript. Она широко применяется в разработке фронтенд-приложений, особенно тех, которые основаны на фреймворках React, Angular или Vue.

**Основная область применения Redux включает:**

1. **Управление состоянием:** Redux предоставляет централизованное хранилище данных для приложения. Он позволяет управлять состоянием приложения и обновлять его согласно определенным правилам и действиям.

2. **Управление сложными состояниями:** Redux облегчает управление сложными состояниями приложения, особенно когда они имеют множество взаимозависимых компонентов или когда требуется обеспечить синхронизацию состояния между различными компонентами.

3. **Отслеживание изменений:** Redux предоставляет возможность отслеживать изменения состояния приложения и реагировать на них. Это помогает обновлять пользовательский интерфейс при изменении данных и поддерживать согласованность между различными частями приложения.

4. **Упрощение тестирования:** Использование Redux облегчает тестирование приложений, поскольку состояние и логика приложения вынесены из компонентов и могут быть тестированы независимо.

5. **Реактивность и отмена действий:** Redux поддерживает концепцию реактивности и позволяет отслеживать и отменять действия, производимые в приложении. Это полезно для реализации функций, таких как отмена последнего действия или восстановление состояния.

В целом, Redux является мощным инструментом для управления состоянием приложения и находит широкое применение во многих фронтенд-приложениях, особенно в тех, которые требуют управления сложными состояниями и взаимодействием между компонентами.

# 2. Связывание react с redux
Связывание React с Redux обеспечивает интеграцию между двумя популярными библиотеками, позволяя управлять состоянием приложения с помощью Redux и использовать его в компонентах React.

**Основные шаги по связыванию React с Redux:**
1. **Установка зависимостей**: Убедитесь, что у вас установлены библиотеки React и Redux с помощью менеджера пакетов, такого как npm или Yarn.

2. **Создание хранилища Redux**: Создайте хранилище Redux, которое будет содержать состояние вашего приложения и обрабатывать действия.

3. **Определение действий**: Определите действия, которые будут использоваться для обновления состояния в Redux. Действия могут быть функциями, возвращающими объекты с типом и данными.

4. **Создание редюсеров**: Создайте редюсеры, которые будут обрабатывать действия и обновлять состояние в хранилище Redux. Редюсеры являются чистыми функциями, которые принимают текущее состояние и действие, и возвращают новое состояние.

5. **Создание контейнерных компонентов**: Создайте контейнерные компоненты в React, которые будут связаны с хранилищем Redux. Контейнерные компоненты подписываются на изменения состояния в хранилище и могут отправлять действия для обновления состояния.

6. **Использование react-redux**: Используйте пакет `react-redux`, который предоставляет удобные методы для связывания React с Redux. Используйте функцию `connect` для связывания контейнерных компонентов с хранилищем и определите, какие части состояния и действия должны быть доступны в компоненте.

7. **Рендеринг компонентов**: Отрендерите ваши компоненты React, включая контейнерные компоненты, которые связаны с Redux. Компоненты могут получать доступ к состоянию и действиям через свойства, передаваемые функцией `connect`.

8. **Диспетчеризация действий**: В компонентах React вы можете использовать функцию `dispatch` для отправки действий в хранилище Redux. Это вызывает редюсеры, которые обновляют состояние в хранилище, и приводит к перерисовке компонентов, подписанных на изменения состояния.

Связывание React с Redux позволяет эффективно управлять состоянием вашего приложения и упрощает разработку масштабируемых и поддерживаемых фронтенд-приложений.



# 3. action, dispatch

Рассмотрим подробнее понятия `action` и `dispatch` в Redux с простыми примерами.

В Redux, `action` представляет собой объект, который описывает какое действие должно быть выполнено. Он содержит информацию о типе действия и дополнительные данные, необходимые для его выполнения. Объект `action` имеет обязательное поле `type`, которое определяет тип действия.

Пример простого **`action`**:

```javascript
const increment = () => {
  return {
    type: 'INCREMENT',
  };
};
```

В этом примере мы создаем `action` с типом "INCREMENT". Это может быть действие, которое увеличивает счетчик или выполняет другую операцию.

`dispatch` является функцией, которая отправляет `action` в хранилище Redux. Он является способом сообщить Redux о необходимости выполнения определенного действия.

Пример использования **`dispatch`**:

```javascript
dispatch(increment());
```

В этом примере мы вызываем `dispatch` и передаем ему `action` `increment()`. Это означает, что мы отправляем `action` с типом "INCREMENT" в хранилище Redux, и Redux выполняет соответствующие обновления состояния, определенные в редюсере.

Таким образом, при вызове `dispatch(increment())`, Redux обнаруживает, что тип действия равен "INCREMENT" и выполняет соответствующую логику в редюсере для обновления состояния.

Обратите внимание, что это простой пример, и обычно `action` может содержать дополнительные данные, которые передаются в редюсер для обновления состояния более динамическим образом.

# 4. Иммутабельность store

Иммутабельность в Redux относится к тому, что состояние хранилища (store) не может быть изменено напрямую. Вместо этого, при каждом обновлении состояния создается новый объект состояния, основанный на предыдущем состоянии. Это означает, что предыдущее состояние остается неизменным, и любые изменения приводят к созданию нового состояния.

Принцип иммутабельности в Redux имеет несколько преимуществ:

1. **Предсказуемость:** Изменение состояния путем создания нового объекта обеспечивает предсказуемость и легче отслеживать изменения. Это помогает в отладке и понимании того, как изменения состояния могут повлиять на приложение.

2. **Возможность отслеживания изменений:** Иммутабельность упрощает отслеживание изменений в состоянии. Redux может эффективно определить, когда состояние было изменено, используя механизмы сравнения ссылок на объекты.

3. **Безопасность:** Иммутабельность обеспечивает безопасность данных, поскольку предыдущее состояние не может быть изменено случайно или нежелательно. Это особенно полезно в многопоточных или параллельных средах.

Пример использования иммутабельности в Redux:

```javascript
// Создание нового состояния на основе предыдущего состояния
const initialState = {
  counter: 0,
};

function reducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, counter: state.counter + 1 }; // Создание нового объекта состояния с обновленным счетчиком
    case 'DECREMENT':
      return { ...state, counter: state.counter - 1 }; // Создание нового объекта состояния с обновленным счетчиком
    default:
      return state;
  }
}
```

В приведенном примере при каждом действии (например, увеличении или уменьшении счетчика) мы создаем новый объект состояния, используя существующее состояние и изменяя только необходимые свойства. Таким образом, предыдущее состояние остается неизменным, и мы можем безопасно выполнять операции сравнения и обновления состояния.

# Junior+
# 1. Комбинирование State и store в компоненте, по какому принципу надо разделять данные

| Категория      | Использование State          | Использование Store Redux  |
|----------------|------------------------------|----------------------------|
| Объем данных   | Хранит только локальные данные компонента. Маленький объем данных. | Хранит глобальное состояние приложения. Большой объем данных. |
| Обновление данных | Обновление данных происходит локально внутри компонента с помощью `setState` или `useReducer`. | Обновление данных происходит через диспетчеризацию действий (`dispatch`) и редукторы. |
| Доступность данных | Доступны только внутри компонента, где были определены. | Доступны для всех компонентов, подключенных к Store. |
| Совместное использование | Не предоставляет механизм для совместного использования данных между компонентами. | Позволяет совместно использовать данные между компонентами через подключение к одному Store. |
| Управление сложным состоянием | Может быть сложно управлять состоянием, если в приложении есть несколько компонентов, которым нужен доступ к одним и тем же данным. | Упрощает управление сложным состоянием приложения, так как глобальное состояние доступно для всех компонентов. |
| Тестирование     | Простое тестирование, так как состояние локально внутри компонента. | Необходимость в тестировании действий и редукторов для обеспечения правильной работы глобального состояния. |

Использование State рекомендуется в случаях, когда вам нужно управлять локальными данными внутри компонента и нет потребности в совместном использовании данных между компонентами. Это особенно полезно для маленьких приложений с простой структурой.

Использование Store Redux стоит рассмотреть, когда у вас есть сложное приложение с большим объемом данных и несколькими компонентами, которым требуется доступ к одним и тем же данным между компонентами

# Middle
# 1. redux-saga, redux-thunk
**Redux-saga и Redux-thunk** - это две популярные библиотеки для управления побочными эффектами в Redux-приложениях.

**Redux-thunk** - это простой способ управлять асинхронными операциями в Redux. Он позволяет нам создавать функции, которые могут быть вызваны вместо обычных действий Redux. Эти функции могут выполнять асинхронные задачи, например, получение данных из сервера, и в конечном итоге отправлять соответствующие действия Redux для обновления состояния вашего приложения.

**Redux-saga** - это немного более сложная библиотека, которая помогает управлять побочными эффектами в Redux-приложениях. Она использует генераторы JavaScript, которые позволяют нам написать более сложную логику для обработки асинхронных операций и других побочных эффектов. Мы можем создавать "саги", которые слушают определенные действия Redux и выполняют соответствующие задачи, например, выполнение последовательности запросов к серверу или обработка событий.

В обоих случаях Redux-thunk и Redux-saga помогают в управлении асинхронными операциями в Redux, но Redux-thunk предлагает более простой подход, используя функции, в то время как Redux-saga предоставляет более мощные возможности и большую гибкость, позволяя написать сложную логику с помощью генераторов JavaScript. 

# 2. Альтернативные подходы к организации store - Feature-first + redux-ducks
Подход **"Feature-first"** (сосредоточение на функциональности) предлагает организацию хранилища Redux вокруг функциональных "фич" или модулей, вместо разбиения его по типам действий, редьюсерам и селекторам. Каждая "фича" представляет собой набор связанных действий, редьюсеров и селекторов, которые относятся к определенной функциональности или возможности вашего приложения. Такой подход способствует лучшей организации кода и снижает сложность масштабирования приложения.

**Redux-ducks** - это паттерн организации хранилища Redux, предложенный Эриком Эллиоттом. Он предлагает объединить все связанные сущности (действия, редьюсеры и селекторы) в один модуль или файл, известный как "duck" (утка). Каждый "duck" представляет собой набор связанных действий, редьюсеров и селекторов, относящихся к определенной функциональности или сущности в вашем приложении. Такая организация помогает сделать код более логически связанным и упрощает его сопровождение.

Оба подхода - "Feature-first" и "redux-ducks" - помогают лучше организовать код в Redux-приложениях, делая его более модульным и понятным. 

# Middle+
# 1. Redux-toolkit
**Redux Toolkit** - это официальная библиотека, разработанная командой Redux, для упрощения работы с Redux и управления состоянием в приложениях. Она предоставляет набор удобных функций и соглашений, которые позволяют ускорить процесс разработки и сделать код более читаемым и поддерживаемым.

Основные возможности Redux Toolkit:
1. Сокращение шаблонного кода: Redux Toolkit предоставляет набор функций, которые сокращают необходимость вручную создавать действия (actions), редьюсеры (reducers) и хранилище (store). Это позволяет сосредоточиться на разработке функциональности, а не на повторении одних и тех же шаблонов.
2. Встроенная обработка неизменяемости: Redux Toolkit включает в себя библиотеку Immer, которая облегчает работу с неизменяемыми данными в Redux. Вы можете изменять состояние напрямую, не создавая глубокие копии объектов.
3. Создание редьюсеров в стиле "слайсов" (slices): Redux Toolkit позволяет создавать редьюсеры в стиле "слайсов", группируя связанные действия и редьюсеры в одном месте. Это делает код более организованным и удобным для чтения и поддержки.
4. Встроенная поддержка асинхронных операций: Redux Toolkit предоставляет удобный способ работы с асинхронными операциями с помощью экономичного инструмента под названием "createAsyncThunk". Он упрощает обработку асинхронных запросов и обновление состояния в зависимости от результатов операций.

Redux Toolkit делает код более компактным и понятным. Она предлагает множество полезных функций, которые помогают сэкономить время и усилия при работе с Redux.


# Senior
# 1. Библиотека для осуществления нормализации данных и упрощенной работы с иммутабельными структурами (immutable, normalizr и т.д.)

## 1.1. Normalizr
Normalizr - это библиотека, которая помогает нормализовать и денормализовать данные, упрощая работу с комплексными структурами данных.

Основная цель Normalizr - это преобразование вложенных и связанных данных в плоскую структуру, разделяя их на отдельные сущности и устанавливая связи между ними. Это позволяет эффективно организовать данные и облегчить их обработку.

Вот пример использования Normalizr с помощью TypeScript:

```typescript
import { normalize, schema } from 'normalizr';

// Определение схемы для сущности
const userSchema = new schema.Entity('users');

// Входные данные
const inputData = {
  id: 1,
  name: 'John Doe',
  email: 'johndoe@example.com'
};

// Нормализация данных
const normalizedData = normalize(inputData, userSchema);

console.log(normalizedData);
```

В этом примере мы создали схему `userSchema` для сущности "пользователь". Затем мы передали входные данные `inputData` и схему в функцию `normalize`. В результате получаем нормализованные данные, где каждая сущность имеет уникальный идентификатор и хранится в объекте.

Результат нормализации будет выглядеть примерно так:

```typescript
{
  result: 1,
  entities: {
    users: {
      1: {
        id: 1,
        name: 'John Doe',
        email: 'johndoe@example.com'
      }
    }
  }
}
```

Здесь `result` содержит идентификатор нормализованной сущности, а `entities` содержит объект с нормализованными данными сущности. Обратите внимание, что идентификатор `1` соответствует сущности "пользователь" в `entities.users`.

Normalizr также поддерживает связи между сущностями, что позволяет нормализовывать данные с более сложными отношениями.

В целом, Normalizr предоставляет удобные инструменты для нормализации данных, которые могут быть полезны при работе с комплексными структурами данных и упрощении их обработки и управления.

## 1.2. immutable и immer

`immutable` и `immer` - это библиотеки, которые помогают работать с неизменяемыми данными в JavaScript и TypeScript. Они предоставляют удобные методы и инструменты для создания и обновления неизменяемых объектов и массивов.

Библиотека `immutable`:

```typescript
import { Map, List } from 'immutable';

// Создание неизменяемого объекта
const immutableMap = Map({ key: 'value' });

// Обновление значения в неизменяемом объекте
const updatedMap = immutableMap.set('key', 'new value');

console.log(immutableMap.get('key')); // 'value'
console.log(updatedMap.get('key')); // 'new value'
```

В этом примере мы используем классы `Map` и `List` из библиотеки `immutable`. Методы классов позволяют создавать и обновлять неизменяемые объекты и массивы. Важно отметить, что при обновлении неизменяемого объекта возвращается новый объект с обновленными значениями, а исходный объект остается неизменным.

Библиотека `immer`:

```typescript
import produce from 'immer';

// Создание неизменяемого объекта с помощью immer
const immutableObject = { key: 'value' };

// Обновление значения в неизменяемом объекте с помощью immer
const updatedObject = produce(immutableObject, draft => {
  draft.key = 'new value';
});

console.log(immutableObject.key); // 'value'
console.log(updatedObject.key); // 'new value'
```

В этом примере мы используем функцию `produce` из библиотеки `immer`. Мы передаем исходный объект и колбэк-функцию, в которой обновляем значения объекта. Иммер возвращает новый неизменяемый объект с обновленными значениями, сохраняя при этом исходный объект неизменным.

Ключевое преимущество использования `immutable` и `immer` заключается в том, что они помогают избежать мутации данных и делают код более предсказуемым и безопасным. Они также улучшают производительность, поскольку позволяют оптимизировать обновление неизменяемых структур данных.

Обратите внимание, что `immutable` и `immer` имеют разные подходы к работе с неизменяемыми данными. `immutable` предоставляет собственные классы и методы для создания и обновления неизменяемых структур данных, в то время как `immer` позволяет обновлять неизменяемые структуры данных с помощью простого и понятного синтаксиса, похожего на мутационный код. 
