# Junior
# 1. TypeScript, область применения

TypeScript - это язык программирования, который представляет собой надстройку над языком JavaScript и добавляет в него статическую типизацию, а также дополнительные функции, такие как интерфейсы, перечисления, дженерики и другие.

TypeScript нацелен на решение проблем, связанных с динамической типизацией в JavaScript, что может привести к ошибкам во время выполнения программы. Статическая типизация позволяет обнаружить многие ошибки на этапе компиляции, а не во время выполнения, что обеспечивает более высокую надежность и удобство разработки.

TypeScript также обеспечивает более высокую читаемость и поддерживаемость кода, благодаря тому, что типы являются частью кода, и компилятор TypeScript может обнаруживать ошибки типов и предоставлять подсказки по использованию API.

TypeScript широко используется для разработки крупных веб-приложений, в том числе фреймворков и библиотек, таких как Angular, React и Vue.js. Он также используется в различных средах разработки, таких как Visual Studio Code и WebStorm, и является популярным инструментом для разработки веб-приложений.

# Junior+
# 1. Как типизация приводит к уменьшению багов

TypeScript - это строго типизированный язык программирования, который позволяет определять типы данных для переменных, функций, объектов и т.д. В отличие от JavaScript, где переменные могут быть присвоены значениям разных типов, TypeScript позволяет определить тип данных, который может быть присвоен переменной, и предупреждает о любых ошибочных присваиваниях типов на этапе компиляции.

Таким образом, использование TypeScript позволяет избежать множества ошибок, связанных с типами данных. Например, если функция ожидает аргумент типа number, а в нее передается строка, в JavaScript это приведет к ошибке во время выполнения программы. В TypeScript же, благодаря строгой типизации, такая ошибка будет обнаружена еще на этапе компиляции, что позволит исправить ее до запуска программы.

Кроме того, TypeScript также позволяет использовать возможности интегрированных сред разработки, таких как автодополнение кода и подсказки, что ускоряет процесс написания кода и снижает вероятность ошибок.

Таким образом, использование TypeScript может значительно сократить количество ошибок и улучшить качество кода, что в свою очередь приводит к увеличению производительности и улучшению пользовательского опыта.


# 2. Основные типы данных в TS

В TypeScript есть все стандартные типы данных из JavaScript, а также дополнительные типы, которые улучшают проверку типов и делают код более безопасным. 

Основные типы данных в TypeScript:

1. **number** - числовой тип данных, который может представлять как целочисленные значения, так и значения с плавающей точкой.
```ts
let num: number = 42;
```

2. **string** - строковый тип данных.
```ts
let str: string = "Hello, TypeScript!";
```

3. **boolean** - логический тип данных.
```ts
let isDone: boolean = false;
```

4. **null** и **undefined** - значения, которые представляют отсутствие значения.
```ts
let n: null = null;
let u: undefined = undefined;
```

5. **object** - объектный тип данных, который может быть использован для описания объектов, массивов и функций.
```ts
let obj: object = { foo: "bar" };
```   

6. **array** - массивный тип данных.
```ts
let arr: number[] = [1, 2, 3];
```   

7. **tuple** - кортежный тип данных, который представляет собой массив фиксированной длины, элементы которого имеют разные типы.
```ts
let tuple: [string, number] = ["foo", 42];
```   

8. **enum** - перечисляемый тип данных, который позволяет задать набор именованных констант.
```ts
enum Color {
    Red,
    Green,
    Blue
}

let color: Color = Color.Green;
```   

9. **any** - тип данных, который позволяет использовать любой тип данных без проверки типов.
```ts
let anyValue: any = "I can be anything";
```   

10. **void** - тип данных, который используется для функций, которые не возвращают значения.
```ts
function logMessage(message: string): void {
    console.log(message);
}
```

11. **never** - тип данных, который представляет собой значения, которые никогда не могут произойти.
```ts
function throwError(message: string): never {
    throw new Error(message);
}
```    

Использование правильных типов данных помогает уменьшить количество ошибок в коде и повышает читаемость и поддерживаемость кода. Типизация также упрощает рефакторинг и разработку больших приложений.

# Middle
# 1. Interface, types
В TypeScript существуют два основных способа определения типов: интерфейсы (interfaces) и типы (types).

Интерфейсы (interfaces) - это способ определения пользовательских типов данных. Они определяют форму объекта и его свойств, а также типы данных, которые эти свойства могут иметь. Интерфейсы могут быть использованы для определения типов данных для функций, классов и объектов.

Например, интерфейс, определяющий структуру объекта пользователя, может выглядеть так (пример 1):
```ts
interface User {
  id: number;
  name: string;
  email: string;
}
```

Затем этот интерфейс может быть использован для определения типа данных для объекта пользователя:
```ts
const user: User = {
  id: 1,
  name: 'John Doe',
  email: 'johndoe@example.com'
};
```

Типы (types) представляют собой альтернативный способ определения пользовательских типов данных в TypeScript. Они позволяют создавать новые типы данных путем комбинации существующих типов данных. Типы могут использоваться для определения типов данных для переменных, функций, классов и других объектов.

Например, тип, определяющий структуру объекта заказа, может выглядеть так:
```ts
type Order = {
  id: number;
  items: string[];
  total: number;
};
```

Затем этот тип может быть использован для определения типа данных для объекта заказа:
```ts
const order: Order = {
  id: 1,
  items: ['Product 1', 'Product 2'],
  total: 100
};
```

Оба способа определения типов данных - интерфейсы и типы - имеют свои преимущества и недостатки, и выбор между ними зависит от конкретных потребностей и предпочтений разработчика. 
Основное различие между интерфейсами и типами заключается в том, что интерфейсы могут определять только типы объектов, тогда как типы могут определять любой тип данных, включая объекты, примитивы, перечисления и объединения типов.

Например, если нам нужно определить тип объекта пользователя, то мы можем использовать интерфейс (пример 1).

Но если нам нужно определить тип данных, который может принимать значение одного из двух возможных типов, мы можем использовать тип:
```ts
type Status = 'active' | 'inactive';
```

Также интерфейсы могут быть расширены, в то время как типы - нет. Это означает, что интерфейсы могут наследовать свойства и методы из других интерфейсов.

Например, мы можем расширить интерфейс пользователя (пример 1), добавив к нему свойство age:
```ts
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}
```

Типы не могут быть расширены, но они могут быть использованы для создания более сложных типов данных, таких как объединения типов (union types) и пересечения типов (intersection types).

# 2. Файлы деклараций .d.ts
Файлы деклараций `.d.ts (declaration files)` в TypeScript используются для описания типов, интерфейсов, модулей, функций и других сущностей в коде JavaScript, которые не содержат информации о типах.

Декларационный файл расширения `.d.ts` может быть использован компилятором TypeScript для проверки типов и облегчения взаимодействия между TypeScript и JavaScript.

Файлы деклараций `.d.ts` могут быть созданы вручную или сгенерированы автоматически для внешних библиотек или модулей JavaScript, не содержащих информации о типах.

Использование декларационных файлов позволяет избежать ошибок во время выполнения, связанных с типами, и обеспечивает более качественную работу TypeScript в сочетании с JavaScript.

# 3. Механизм typeGuard
TypeGuard - это механизм в TypeScript, который позволяет определить, имеет ли переменная определенный тип во время выполнения программы.

TypeGuard используется для уточнения типов ветвления, когда мы не уверены, какой тип имеет переменная в данный момент выполнения программы. Например, мы можем проверить, является ли переменная массивом, объектом или числом, и выполнить соответствующую операцию в зависимости от ее типа.

TypeGuard может быть реализован с помощью следующих механизмов:

Проверка типа (Type Checking) - позволяет проверять тип переменной или свойства объекта и в зависимости от результата выполнять определенные действия.

Проверка наличия свойства (Property Checking) - позволяет проверять наличие свойства у объекта и в зависимости от этого выполнять определенные действия.

Пользовательский TypeGuard (User-Defined Type Guard) - это функция, которая определяет, имеет ли переменная определенный тип. Эта функция возвращает логическое значение, которое указывает, является ли переменная указанного типа.

Пример использования TypeGuard:
```ts
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

type Shape = Circle | Square;

function getArea(shape: Shape) {
  if (shape.kind === "circle") {
    return Math.PI * shape.radius ** 2;
  } else if (shape.kind === "square") {
    return shape.sideLength ** 2;
  }
}
```

В данном примере, мы используем TypeGuard, чтобы определить тип объекта `Shape`. Если `kind === "circle"`, то мы знаем, что это объект типа `Circle` и можем безопасно обращаться к его свойствам. Если `kind === "square"`, то мы знаем, что это объект типа Square и также можем безопасно обращаться к его свойствам.

# 4. Преобразование типов (extend, |, &, UtilityTypes)
Преобразование типов в TypeScript позволяет создавать новые типы на основе уже существующих. Рассмотрим несколько механизмов для преобразования типов.

**Extend**
Механизм extend позволяет наследовать свойства одного типа от другого. Например:
```ts
interface User {
  name: string;
  age: number;
}

interface Admin extends User {
  isAdmin: boolean;
}
```

В данном случае интерфейс `Admin` наследует свойства от интерфейса `User`, а также добавляет свойство `isAdmin`.

**Union types**
Механизм `union types` позволяет объединять два или более типа в один. Например:
```ts
type User = {
  name: string;
  age: number;
};

type Admin = {
  isAdmin: boolean;
};

type Person = User | Admin;
```

В данном случае тип `Person` может принимать значения `User` или `Admin`.

**Intersection types**
Механизм `intersection types` позволяет создавать новый тип, объединяя два или более типа в один, содержащий все свойства и методы из каждого типа. Например:
```ts
interface User {
  name: string;
  age: number;
}

interface Admin {
  isAdmin: boolean;
}

type SuperAdmin = User & Admin;
```

В данном случае тип `SuperAdmin` объединяет интерфейсы `User` и `Admin` и содержит свойства и методы из каждого из них.

**Utility types**
TypeScript также предоставляет набор `utility types`, которые позволяют создавать новые типы на основе существующих. Например:

`Partial<T>` - создает тип, содержащий все свойства из типа `T`, но каждое свойство делается необязательным.
`Required<T>` - создает тип, содержащий все свойства из типа `T`, но каждое свойство делается обязательным.
`Pick<T, K>` - создает тип, содержащий только указанные свойства `K` из типа `T`.
`Omit<T, K>` - создает тип, исключая указанные свойства `K` из типа `T`.
Например:
```ts
interface User {
  name: string;
  age: number;
  email: string;
}

type UserWithoutEmail = Omit<User, 'email'>;
```

В данном случае создается новый тип `UserWithoutEmail`, исключающий свойство `email` из интерфейса `User`.

# 5. Generics
Generics в TypeScript - это механизм для создания компонентов, которые могут работать с различными типами данных, не определяя конкретный тип в самом компоненте. Вместо этого, тип определяется при использовании компонента.

Для создания обобщенных компонентов в TypeScript используется параметр типа, который заключается в угловые скобки `<>` внутри определения компонента. Например, следующий компонент `identity` принимает параметр типа `T` и возвращает аргумент, приведенный к типу `T`:
```ts
function identity<T>(arg: T): T {
  return arg;
}
```

При вызове этого компонента мы указываем тип, который будет использоваться для `T`. Например:
```ts
let output = identity<string>("hello world");
console.log(output); // "hello world"
```

Здесь мы указали, что `T` должен быть строковым типом.

Кроме того, TypeScript предоставляет множество утилитарных типов, которые могут использоваться с обобщенными типами. Например, тип `Partial<T>` делает все свойства объекта необязательными:
```ts
interface Person {
  name: string;
  age: number;
}

function updatePerson(person: Person, updates: Partial<Person>) {
  return { ...person, ...updates };
}

let person: Person = { name: "Alice", age: 30 };
let updatedPerson = updatePerson(person, { age: 31 });
console.log(updatedPerson); // { name: "Alice", age: 31 }
```

Здесь мы использовали тип `Partial<Person>`, чтобы указать, что все свойства объекта `updates` являются необязательными.

# 6. Keyof, typeof
keyof и typeof - это операторы TypeScript, которые используются для работы с типами.

keyof - это оператор, который возвращает тип, представляющий все возможные ключи объекта. Например:
```ts
interface Person {
  name: string;
  age: number;
}

type PersonKeys = keyof Person;
// Это эквивалентно:
// type PersonKeys = "name" | "age"
```

В этом примере мы использовали оператор `keyof` для получения типа `PersonKeys`, который содержит все возможные ключи объекта `Person`.

`typeof` - это оператор, который возвращает тип значения выражения. Например:
```ts
const person = { name: "Alice", age: 30 };

type PersonType = typeof person;
// Это эквивалентно:
// type PersonType = { name: string, age: number }
```

В этом примере мы использовали оператор `typeof` для получения типа `PersonType`, который содержит тип значений объекта `person`.

Оба оператора могут использоваться вместе с обобщенными типами для создания более гибких компонентов. Например, следующий компонент принимает объект и ключ свойства, а затем возвращает значение этого свойства:
```ts
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

const person = { name: "Alice", age: 30 };
const name = getProperty(person, "name");
console.log(name); // "Alice"
```

Здесь мы использовали обобщенные типы и оператор `keyof`, чтобы указать, что ключ `K` должен быть одним из возможных ключей объекта `T`. Таким образом, компонент `getProperty` может быть использован с любым объектом и любым ключом свойства, который существует в этом объекте.

# Middle+
# 1. Optional chaining, nullish coalescing
**Optional chaining** и **nullish coalescing** - это две функции, которые были добавлены в ECMAScript 2020 и позволяют написать более чистый и краткий код, особенно при работе с вложенными объектами и потенциально пустыми значениями.

Оператор `Optional chaining` позволяет безопасно обращаться к свойствам объектов, которые могут быть `undefined` или `null`. Вместо использования длинной цепочки проверок на `undefined` или `null`, можно использовать оператор `?.` для проверки наличия свойства. Например:
```ts
const foo = { bar: { baz: 42 } };
const bazValue = foo.bar?.baz; // 42

const foo2 = { bar: null };
const bazValue2 = foo2.bar?.baz; // undefined
```

Оператор `Nullish coalescing` позволяет выбирать значение по умолчанию, если значение переменной равно `null` или `undefined`. Вместо использования оператора `||` для проверки наличия значения, можно использовать оператор `??`, который проверяет только на `null` или `undefined`. Например:

```ts
const foo = null;
const bar = foo ?? 'default value'; // 'default value'

const baz = 0;
const qux = baz ?? 42; // 0
```

Эти операторы могут быть очень полезны при работе с неопределенными значениями, такими как значения из API-запросов или свойства объектов, которые могут быть неопределенными. Они позволяют более безопасно и эффективно работать с такими значениями в TypeScript.

# 2. Conditional types, mapped tapes, infer
`Conditional types`, `mapped types` и `infer` - это функциональности, добавленные в TypeScript, которые позволяют создавать сложные типы и работать с ними.

**Mapped types** позволяют создавать новый тип на основе существующего типа. Это делается путем создания нового типа, который перебирает все свойства существующего типа и создает новые свойства на основе существующих. Пример:
```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

interface User {
  name: string;
  age: number;
}

type ReadonlyUser = Readonly<User>;
```

Теперь `ReadonlyUser` будет иметь такую же структуру, как и User, но все свойства будут помечены как readonly.

**Conditional types** (условные типы) - это функциональность TypeScript, которая позволяет создавать типы, зависящие от условий. Они используются для определения типа в зависимости от другого типа или значения.

Синтаксис условных типов выглядит следующим образом: `T extends U ? X : Y`, где `T` и `U` - это типы,`X` и `Y` - это типы, которые будут использоваться, если `T` расширяет `U` или нет, соответственно.

Рассмотрим следующий пример:
```ts
type Check<T> = T extends string ? true : false;

type A = Check<string>; // true
type B = Check<number>; // false
```

В этом примере мы определяем тип `Check`, который проверяет, является ли тип `T` строкой. Если `T` является строкой, то `Check` возвращает тип `true`, иначе возвращает тип `false`.

**Mapped types** (отображаемые типы) - это еще одна возможность TypeScript, которая позволяет создавать новые типы, основанные на старых. Они позволяют изменять свойства объектов и создавать новые типы из существующих типов.

`Mapped types` могут быть созданы с помощью ключевого слова `in`, которое позволяет перебирать свойства объекта. Синтаксис отображаемых типов выглядит следующим образом: `{ [P in K]: T }`, где `P` - это имя свойства, `K` - это тип ключа (например, `string` или `number`), `T` - это тип значения.

Рассмотрим следующий пример:
```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
}

interface User {
  name: string;
  age: number;
}

const user: Readonly<User> = { name: "John", age: 30 };
user.name = "Mike"; // Ошибка: свойство только для чтения
```

В этом примере мы определяем тип `Readonly`, который делает все свойства объекта только для чтения. Мы используем ключевое слово `keyof` для получения списка ключей свойств объекта, а затем используем синтаксис отображаемых типов для создания нового типа, в котором каждое свойство помечено как `readonly`.

**Infer**
`infer` - это ключевое слово в TypeScript, которое используется в условных типах. Оно позволяет "извлекать" тип из другого типа, чтобы использовать его в дальнейшем.

Например, в условном типе мы можем использовать ключевое слово `infer` для "извлечения" типа из типа функции и присвоения этого типа переменной:
```ts
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
```

В этом примере мы определяем обобщенный тип `ReturnType<T>`, который принимает тип функции `T` и извлекает тип ее возвращаемого значения с помощью ключевого слова `infer`.

Затем мы используем условный оператор extends для проверки, является ли `T` типом функции. Если это так, мы "извлекаем" тип возвращаемого значения и присваиваем его переменной `R` с помощью ключевого слова `infer`. Если `T` не является функцией, мы возвращаем тип `never`.

Таким образом, при вызове `ReturnType` с типом функции, мы получим тип ее возвращаемого значения.

# Senior
# 1. Template Literal Types

Template Literal Types - это новая функциональность в TypeScript 4.1, которая позволяет использовать строки в качестве типов данных. Они представляют собой типы, которые строятся из литералов шаблонных строк, которые могут быть использованы для создания новых типов данных на основе существующих.

**Шаблонные литералы** позволяют использовать вложенность шаблонных строк и операторы шаблонных строк для создания типов, которые точно соответствуют структуре входных данных. Они могут использоваться для создания узкоспециализированных типов, которые могут быть использованы для повышения точности проверки типов.

Например, вот как вы можете определить тип, который представляет путь к файлу:

```ts
type FilePath<T extends string> = `./src/${T}`
```

Здесь мы определяем шаблонный тип `FilePath`, который принимает тип строки `T` и объединяет его с литералом "./src/". Это позволяет использовать тип `FilePath` для определения путей к файлам, которые начинаются с "./src/".

Кроме того, шаблонные литералы могут использоваться для создания условных типов, которые зависят от значения переменной или значения другого типа. Например, вот как можно использовать шаблонные литералы для создания условного типа, который преобразует строковое значение в число, только если оно является числом:

```ts
type StringToNumber<S extends string> = S extends `${number}` ? number : never;
```

Здесь мы определяем шаблонный тип `StringToNumber`, который проверяет, является ли тип `S` строкой, которая может быть преобразована в число. Если это так, тип `StringToNumber` преобразуется в число, в противном случае он преобразуется в `never`.

Template Literal Types позволяют создавать более точные и узкоспециализированные типы данных, что может помочь уменьшить количество ошибок в вашем коде и улучшить проверку типов во время компиляции.

# 2. Перегрузка функций

Перегрузка функций - это возможность определения одной функции с разными наборами параметров и возвращаемых типов. При вызове функции компилятор TypeScript выбирает наиболее подходящую перегрузку на основе переданных аргументов.

Для определения перегруженных функций в TypeScript используется ключевое слово `function` с несколькими сигнатурами. Каждая сигнатура содержит список параметров и тип возвращаемого значения.

Пример:

```typescript
function calculateArea(width: number, height: number): number;
function calculateArea(length: number): number;
function calculateArea(arg1: number, arg2?: number): number {
  if (arg2) {
    return arg1 * arg2;
  } else {
    return arg1 * arg1;
  }
}
```

Здесь функция `calculateArea` имеет две сигнатуры: одна с двумя параметрами (`width` и `height`), другая с одним параметром (`length`). Обе сигнатуры возвращают число. Реализация функции расположена после сигнатур и содержит проверку наличия второго аргумента и соответствующий расчет площади.

Таким образом, при вызове `calculateArea` с двумя аргументами будет выбрана первая перегрузка, а при вызове с одним аргументом - вторая перегрузка.

Использование перегрузок функций может существенно повысить читаемость и понятность кода, а также снизить количество ошибок при разработке.

# 3. Reference types

`/// <reference types="..." />` - это директива в TypeScript, которая используется для указания ссылки на объявления типов, которые используются в проекте.

Директива `/// <reference types="..." />` указывает TypeScript на необходимость использования определенных типов в проекте, которые могут быть предоставлены сторонними библиотеками и установлены через менеджер пакетов npm. Это позволяет TypeScript проверять типы, связанные с этими сторонними библиотеками, и обеспечивает лучшую интеграцию между проектом и используемыми библиотеками.

Пример использования `/// <reference types="..." />`:

```typescript
/// <reference types="react" />

function MyComponent(props: React.PropsWithChildren<MyComponentProps>) {
  return (
    <div>{props.children}</div>
  );
}
```

В этом примере мы указываем, что наш компонент `MyComponent` использует типы из библиотеки React. Это позволяет TypeScript корректно проверять типы для всех свойств и пропсов, которые мы используем в компоненте.

# 4. Использование tsc
`tsc` (TypeScript Compiler) — это инструмент командной строки для компиляции TypeScript кода в JavaScript. Он является частью TypeScript инструментария и устанавливается вместе с TypeScript.

Для использования `tsc` необходимо сначала установить TypeScript. Для этого можно воспользоваться менеджером пакетов `npm`:

```ts
npm install -g typescript
```

После установки TypeScript можно скомпилировать TypeScript файлы в JavaScript. Для этого нужно запустить `tsc` и указать путь к файлу или каталогу, содержащему файлы TypeScript:

```ts
tsc path/to/file.ts
```

По умолчанию, `tsc` создаст JavaScript файлы с тем же именем, что и у соответствующих TypeScript файлов, и расширением `.js`.

`tsc` также поддерживает ряд опций, которые можно использовать для настройки процесса компиляции. Например, можно указать целевую версию ECMAScript, задать путь к файлу конфигурации и т.д. Полный список опций можно посмотреть в документации TypeScript.
