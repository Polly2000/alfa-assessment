# Junior
# 1. DevTools (network, application)
!
DevTools - это инструменты разработчика в браузерах, которые предоставляют удобный интерфейс для отладки и тестирования веб-приложений. Они могут быть использованы для анализа производительности, отображения HTML и CSS, отладки JavaScript и т.д.

Network DevTools позволяет анализировать все сетевые запросы, которые были выполнены при загрузке веб-страницы. Вы можете видеть детали каждого запроса, такие как URL-адрес, тип запроса, заголовки, параметры, время выполнения и т.д. Вы также можете анализировать производительность веб-страницы, определяя, сколько времени занимает каждый запрос, сколько данных загружается и т.д.

Application DevTools позволяет работать с локальным хранилищем, куки, сеансами и другими данными, которые используются веб-приложением. Вы можете просматривать, изменять и удалять эти данные.

Например, с помощью DevTools можно:

Отлаживать JavaScript-код, устанавливать точки останова, анализировать переменные и т.д.
Анализировать производительность веб-страницы, определяя, какие запросы занимают больше всего времени, какие скрипты выполняются медленно и т.д.
Изучать и изменять HTML и CSS код в режиме реального времени.
Проверять соответствие веб-страницы стандартам доступности и безопасности.
Работать с локальным хранилищем, куки, сеансами и другими данными, которые используются веб-приложением.
Пример использования Network DevTools:

Откройте веб-страницу, которую вы хотите проанализировать в браузере Chrome.
Откройте DevTools, нажав F12 или используя сочетание клавиш Ctrl+Shift+I.
Перейдите на вкладку "Network".
Обновите страницу в браузере, чтобы начать анализ сетевых запросов.
Вы увидите список всех запросов, выполненных при загрузке веб-страницы. Вы можете анализировать каждый запрос, чтобы узнать дополнительные сведения о его длительности, размере, типе и т.д.
Пример использования Application DevTools:

Откройте веб-страницу, которую вы хотите проанализировать в браузере Chrome.
Откройте DevTools, нажав F12 или используя сочетание клавиш


# 2. Breakpoints

Breakpoints - это точки останова в коде, в которых выполнение программы приостанавливается, чтобы разработчик мог проанализировать текущее состояние приложения. Breakpoints позволяют более эффективно отлаживать код, поэтому они являются одним из наиболее важных инструментов для разработчиков.

В DevTools браузера Chrome и других современных браузеров есть возможность установки breakpoints на строках кода, функциях, условиях и событиях. При достижении точки останова выполнение программы приостанавливается, и разработчик может проанализировать состояние приложения в текущий момент.

Например, если в коде приложения есть ошибка, разработчик может установить точку останова на строке, где происходит ошибка, и проанализировать значения переменных, чтобы выяснить причину ошибки. Также можно использовать breakpoints для отслеживания выполнения асинхронного кода, чтобы понимать, какие запросы выполняются и какие данные получаются.

DevTools также предоставляет возможность условных breakpoints, которые позволяют установить точку останова только в том случае, если определенное условие выполняется. Это очень полезно, например, когда вы хотите установить точку останова только в том случае, если значение переменной превышает определенный порог.

# Junior+
# 1.  LocalStorage

localStorage - это механизм хранения данных в браузере, который позволяет сохранять данные между сеансами браузера и даже после перезапуска компьютера.

Для работы с localStorage в JavaScript используется глобальный объект localStorage, который предоставляет методы для управления данными в локальном хранилище. Для добавления данных в localStorage используется метод setItem(), который принимает ключ и значение. Например, чтобы добавить строку "Hello, world!" с ключом "greeting" в localStorage, можно использовать следующий код:
```ts
localStorage.setItem('greeting', 'Hello, world!');
```


Чтобы получить данные из localStorage, можно использовать метод getItem(), который принимает ключ и возвращает соответствующее значение. Например, чтобы получить строку "Hello, world!" по ключу "greeting", можно использовать следующий код:
```ts
const greeting = localStorage.getItem('greeting');
console.log(greeting); // "Hello, world!"
```

Если данных с указанным ключом в localStorage нет, то метод getItem() вернет null. Чтобы удалить данные из localStorage, можно использовать метод removeItem(), который принимает ключ. Например, чтобы удалить данные с ключом "greeting", можно использовать следующий код:
```ts
localStorage.removeItem('greeting');
```

Кроме того, localStorage имеет свойство length, которое возвращает количество элементов в хранилище, и метод clear(), который удаляет все данные из localStorage:
```ts
console.log(localStorage.length); // 1
localStorage.clear();
console.log(localStorage.length); // 0
```

localStorage позволяет хранить только простые типы данных, такие как строки, числа, булевы значения и null. Для хранения сложных объектов, таких как массивы и объекты, необходимо использовать метод JSON.stringify() для преобразования объекта в строку перед сохранением и метод JSON.parse() для преобразования строки обратно в объект после получения данных из localStorage. Например:
```ts
const myArray = [1, 2, 3];
localStorage.setItem('myArray', JSON.stringify(myArray));

const storedArray = JSON.parse(localStorage.getItem('myArray'));
console.log(storedArray); // [1, 2, 3]
```

# 2. Iframe

<iframe> - это HTML-элемент, который позволяет встраивать один HTML-документ в другой. Он может быть использован для вставки рекламы, видео, карт или других веб-страниц внутри основного документа.

Для создания <iframe> необходимо указать атрибуты src, width и height, которые определяют источник внедряемой страницы и ее размеры. Также, можно добавить другие атрибуты, такие как name, sandbox и allowfullscreen.

Пример:
```ts
html
<!DOCTYPE html>
<html>
  <head>
    <title>Parent Page</title>
  </head>
  <body>
    <h1>Welcome to the parent page</h1>
    <iframe src="https://www.example.com" width="800" height="600"></iframe>
  </body>
</html>
```

Здесь мы создаем основной документ и вставляем <iframe>, который загружает страницу по адресу https://www.example.com с шириной 800 и высотой 600 пикселей.

# Middle
# 1. WebSocket

WebSocket - это протокол, который обеспечивает двустороннюю связь между клиентом и сервером через одно соединение TCP. Этот протокол предоставляет возможность установления постоянного канала связи между клиентом и сервером, который позволяет передавать данные в режиме реального времени без необходимости повторного установления соединения.

Для работы с WebSocket в браузере используется объект WebSocket, который имеет несколько методов, таких как send() для отправки данных на сервер и close() для закрытия соединения. WebSocket также имеет несколько событий, таких как onopen, onmessage, onclose и onerror, которые позволяют отслеживать состояние соединения и обрабатывать входящие данные.

Пример использования WebSocket для отправки и получения данных между клиентом и сервером:
```ts
// Создание объекта WebSocket
const socket = new WebSocket('wss://example.com');

// Обработка события открытия соединения
socket.onopen = () => {
  console.log('Соединение установлено');
  
  // Отправка данных на сервер
  socket.send('Hello, server!');
};

// Обработка входящих данных
socket.onmessage = event => {
  console.log(`Получены данные: ${event.data}`);
  
  // Закрытие соединения
  socket.close();
};

// Обработка события закрытия соединения
socket.onclose = event => {
  console.log(`Соединение закрыто: ${event.code}`);
};

// Обработка ошибок
socket.onerror = error => {
  console.error(`Ошибка WebSocket: ${error.message}`);
};
```

WebSocket используется в различных приложениях, таких как чаты, онлайн-игры, трансляции видео и аудио и т.д.


# 2. Cookies

Cookies - это небольшие текстовые файлы, которые хранятся на устройстве пользователя веб-браузером. Они используются для хранения данных, которые могут быть использованы на сайте для различных целей, таких как запоминание предпочтений пользователя или аутентификации.

Пример использования cookies может быть следующим: сайт может сохранять в cookie информацию о пользователе, который входит на сайт. Это позволяет сайту автоматически входить пользователя при каждом посещении, не требуя повторной аутентификации.

Cookies могут быть установлены с помощью объекта document.cookie. Например, чтобы установить cookie с именем "username" и значением "john", можно использовать следующий код:
```ts
document.cookie = "username=john";
```

Также можно добавить необязательные параметры для установки времени жизни cookie, его пути и домена. Например:
```ts
document.cookie = "username=john; expires=Thu, 01 Jan 2025 00:00:00 UTC; path=/; domain=example.com";
```

При чтении **cookie** из JavaScript можно использовать свойство **document.cookie**. Оно возвращает все cookie, связанные с текущим доменом, в виде строки. Можно использовать метод **split()** для преобразования строки в массив отдельных **cookie**. Например:
```ts
let cookies = document.cookie.split(';');
```

Cookies могут также быть удалены путем установки срока действия cookie на прошедшую дату. Например:
```ts
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=example.com";
```

# Middle+
# 1. Безопасность cookie

При работе с cookies важно обеспечить их безопасность, чтобы злоумышленники не могли получить доступ к конфиденциальным данным пользователей. Некоторые меры безопасности включают:

1. Ограничение срока действия. Установка длительного срока хранения cookies может привести к утечкам информации. Рекомендуется устанавливать короткие сроки действия и очищать cookies после их использования.

2. Использование параметра Secure. Если параметр Secure установлен, то cookies будут отправляться только через зашифрованные соединения HTTPS.

3. Использование параметра HttpOnly. При использовании параметра HttpOnly, cookies не могут быть доступны через JavaScript. Это помогает защитить cookies от атаки с использованием XSS.

Установка cookies на сервере может быть выполнена с помощью заголовков HTTP. Вот пример использования Node.js и Express для установки cookies с параметром HttpOnly:
```ts
const express = require('express');
const cookieParser = require('cookie-parser');

const app = express();
app.use(cookieParser());

app.get('/', (req, res) => {
  res.cookie('mycookie', 'myvalue', { httpOnly: true });
  res.send('Cookie set');
});

app.listen(3000, () => {
  console.log('Server listening on port 3000');
});
```

Когда пользователь запрашивает главную страницу, сервер устанавливает cookie с именем "mycookie" и значением "myvalue". Параметр HttpOnly гарантирует, что cookie будет недоступен через JavaScript.

В целом, важно тщательно оценить риски и применить соответствующие меры безопасности при работе с cookies, чтобы защитить конфиденциальную информацию пользователей.

# 2. Установка cookies сервером, httpOnly

Когда пользователь запрашивает главную страницу, сервер устанавливает cookie с именем "mycookie" и значением "myvalue". Параметр HttpOnly гарантирует, что cookie будет недоступен через JavaScript.

При использовании параметра HttpOnly, cookies не могут быть доступны через JavaScript. Это помогает защитить cookies от атаки с использованием XSS.

# Senior
# 1. Service Workers

Service workers - это сценарии JavaScript, которые выполняются в фоновом режиме браузера и предоставляют дополнительную функциональность, которая не доступна обычным скриптам веб-страницы. Они используются для кэширования ресурсов, таких как изображения, стили и скрипты, чтобы они могли быть быстро загружены и использованы оффлайн. Они также могут использоваться для отправки уведомлений пользователю или для обработки фоновых задач, таких как обновление контента или синхронизация данных.

Сервис-воркеры могут работать с любым протоколом, включая HTTP и HTTPS, а также могут обрабатывать запросы с других источников. **Они не имеют доступа к DOM и работают в отдельном потоке**, что позволяет им работать асинхронно, не блокируя основной поток браузера.

Пример использования сервис-воркера для кэширования ресурсов:
```ts
// регистрация сервис-воркера
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js')
    .then(function(registration) {
      console.log('Service worker registered successfully');
    })
    .catch(function(err) {
      console.error('Error registering service worker:', err);
    });
}

// установка обработчика события fetch для кэширования ресурсов
self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request).then(function(response) {
      if (response) {
        return response;
      } else {
        return fetch(event.request).then(function(response) {
          return caches.open('my-cache').then(function(cache) {
            cache.put(event.request, response.clone());
            return response;
          });
        });
      }
    })
  );
});
```

В этом примере мы регистрируем сервис-воркер и устанавливаем обработчик события fetch, который проверяет, есть ли запрошенный ресурс в кэше. Если ресурс найден в кэше, он возвращается, в противном случае он загружается из сети и добавляется в кэш для будущего использования.

Сервис-воркеры также могут использоваться для обработки событий push-уведомлений и синхронизации данных между клиентом и сервером в фоновом режиме.


# 2. Web-workers

Web Workers - это механизм, позволяющий выполнять скрипты в фоновом потоке, отличном от основного потока, который обрабатывает пользовательский интерфейс. Они позволяют выполнять тяжелые вычисления, работу с сетью и другие задачи, которые могут замедлить пользовательский интерфейс, не блокируя его работу.

Web Workers создаются с помощью объекта Worker и принимают в качестве аргумента URL-адрес скрипта, который будет выполняться в фоновом потоке. Веб-воркеры не имеют доступа к глобальным переменным и функциям в основном потоке, но могут обмениваться данными с основным потоком, используя механизмы передачи сообщений.

Пример создания и обмена данными с веб-воркером:
```ts
// создаем веб-воркер
const worker = new Worker('worker.js');

// отправляем сообщение в веб-воркер
worker.postMessage({type: 'start', data: [1, 2, 3, 4, 5]});

// принимаем сообщение от веб-воркера
worker.onmessage = function(event) {
  console.log(event.data);
};

// скрипт worker.js
onmessage = function(event) {
  const data = event.data.data;
  const sum = data.reduce((acc, val) => acc + val);
  postMessage({type: 'result', data: sum});
};
```

В этом примере мы создаем веб-воркер, отправляем ему сообщение с массивом данных, который нужно обработать, и принимаем результат в основном потоке. В веб-воркере мы обрабатываем данные, вычисляем их сумму и отправляем результат обратно в основной поток.

Web Workers - это мощный механизм, который может повысить производительность и отзывчивость веб-приложений, особенно для тех задач, которые требуют много времени и ресурсов.


# 3. Web APIs (Payment request API, Push API, WebShare API и т.д.)

Web APIs - это набор различных API (Application Programming Interface) веб-платформы, которые позволяют разработчикам создавать более интерактивные и богатые по функционалу веб-приложения. Они предоставляют доступ к функциям браузера, таким как мультимедиа, геопозиционирование, уведомления, работа с файлами, доступ к камере и микрофону и многое другое.

Некоторые из наиболее популярных веб-API включают:

## 3.1. Payment Request API
позволяет веб-приложениям просить у пользователя информацию об оплате товаров и услуг. API облегчает процесс оплаты, уменьшает количество ошибок и повышает безопасность транзакций.

Пример использования Payment Request API:
```ts
const paymentRequest = new PaymentRequest(
  supportedPaymentMethods,
  paymentDetails,
  options
);

paymentRequest.show().then((paymentResponse) => {
  // Обработка ответа
}).catch((err) => {
  // Обработка ошибки
});
```

## 3.2. Push API
позволяет отправлять уведомления пользователям, даже когда приложение не запущено. API использует технологию push-уведомлений, которая работает в фоновом режиме, чтобы уведомлять пользователей о новых событиях, таких как новые сообщения, обновления контента и т.д.

Пример использования Push API:
```ts
const publicKey = 'BNUX...';
navigator.serviceWorker.register('service-worker.js');

navigator.serviceWorker.ready.then((registration) => {
  registration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: urlBase64ToUint8Array(publicKey)
  }).then((subscription) => {
    // Отправка уведомлений
  }).catch((err) => {
    // Обработка ошибки
  });
});
```

## 3.3. Web Share API
позволяет приложениям предлагать пользователю возможность быстрой и простой передачи ссылок, текста, изображений и другого контента через доступные приложения и сервисы.

Пример использования Web Share API:
```ts
if (navigator.share) {
  navigator.share({
    title: 'Web Share API',
    text: 'Поделитесь контентом быстро и просто',
    url: 'https://example.com'
  }).then(() => {
    console.log('Контент успешно опубликован');
  }).catch((err) => {
    console.log('Ошибка: ' + err);
  });
}
```
Эти API и многие другие позволяют создавать более мощные, интерактивные и удобные веб-приложения. Они могут быть использованы для улучшения пользовательского опыта, упрощения процессов и повышения безопасности веб-приложений.

# 4. IndexDB

IndexedDB - это низкоуровневый API для хранения структурированных данных на стороне клиента в браузере. Он позволяет хранить и управлять большими объемами данных, которые можно использовать в автономном режиме или в сетевой среде. IndexedDB основывается на модели **NoSQL** и позволяет использовать объекты JavaScript для хранения данных.

Основные компоненты IndexedDB:
1. Базы данных (databases) - контейнеры для хранения данных.
2. Объектные хранилища (object stores) - места для хранения объектов, содержащих данные.
3. Индексы (indexes) - ускорители поиска, которые позволяют быстро находить нужные данные.

IndexedDB API асинхронный и использует промисы для обработки запросов. Он имеет множество методов для работы с базами данных, объектными хранилищами и индексами, а также событий, которые могут быть использованы для отслеживания изменений в базе данных.

Пример использования IndexedDB:
```ts
// Создание базы данных
const request = indexedDB.open('myDatabase', 1);

request.onupgradeneeded = function(event) {
  const db = event.target.result;
  const objectStore = db.createObjectStore('customers', { keyPath: 'id' });
  objectStore.createIndex('name', 'name', { unique: false });
  objectStore.createIndex('email', 'email', { unique: true });
};

request.onsuccess = function(event) {
  const db = event.target.result;
  const transaction = db.transaction('customers', 'readwrite');
  const objectStore = transaction.objectStore('customers');
  const customer = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };
  objectStore.add(customer);
};
```

В этом примере мы создаем базу данных с именем myDatabase и версией 1. Затем мы создаем объектное хранилище с именем customers и двумя индексами. После этого мы добавляем объект с данными в хранилище.

