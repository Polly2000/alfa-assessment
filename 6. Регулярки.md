# Junior
# 1. Назначение регулярных выражений

Регулярные выражения в JavaScript (и не только) используются для поиска и/или замены текста в строках с помощью определенных шаблонов. Они позволяют более гибко и удобно работать с текстовыми данными, чем стандартные методы строковых операций.

Регулярные выражения представляют собой последовательность символов, которые определяют шаблон для поиска текста. К примеру, регулярное выражение /[a-z]+/g означает поиск всех последовательностей символов от a до z включительно, состоящих из одного или более символов, и нахождение их во всей строке.

Регулярные выражения могут использоваться в различных задачах, таких как проверка правильности ввода пользователем информации в формы, поиск и фильтрация данных в текстовых файлах или базах данных и т.д. Они также широко используются в различных языках программирования и инструментах разработки.

Кроме того, JavaScript предоставляет множество методов для работы с регулярными выражениями, таких как test, exec, match, replace, search и другие. Они позволяют выполнять различные операции, такие как проверка соответствия шаблону, извлечение подстрок, замена текста и т.д.


# 2. Создание регулярных выражений через литерал

В JavaScript регулярные выражения могут быть созданы через литерал, который выглядит как /pattern/flags, где pattern - это шаблон регулярного выражения, а flags - это опциональные флаги, которые определяют как регулярное выражение будет сопоставляться со строкой.

Например, следующее регулярное выражение ищет все цифры в строке:
```ts
const pattern = /\d+/;
```

Здесь **/\d+/** - это литерал регулярного выражения, который содержит шаблон **\d+**, где **\d** означает любую цифру, а **+** означает, что цифра должна встретиться один или более раз.

Также можно использовать конструктор **RegExp()** для создания регулярных выражений:
```td
const pattern = new RegExp('\\d+');
```

В этом случае шаблон **\d+** передается в конструктор **RegExp()** как строка, а обратный слэш используется для экранирования символа **\**.

Оба метода создания регулярных выражений могут использоваться для создания выражений, которые будут использоваться для поиска, замены и валидации строк.


# Junior+
# 1. Основные спец. символы: \d, \s и другие, в том числе границы: ^,$ и т.д.

Регулярные выражения (RegExp) в JavaScript позволяют искать и манипулировать строками с помощью определенных шаблонов. В этом контексте, специальные символы - это символы, которые имеют специальное значение в регулярном выражении, например, для обозначения границы слова или для поиска цифры.

Некоторые из основных специальных символов:

- **\d**: обозначает любую цифру (0-9).
- **\D**: обозначает любой символ, кроме цифры.
- **\w**: обозначает любую букву, цифру или символ подчеркивания.
- **\W**: обозначает любой символ, кроме буквы, цифры или символа подчеркивания.
- **\s**: обозначает любой пробельный символ, включая пробел, табуляцию, перевод строки и другие.
- **\S**: обозначает любой непробельный символ.
- **.**: обозначает любой символ, кроме перевода строки.
- **^**: обозначает начало строки.
- **$**: обозначает конец строки.
- **[]**: обозначает любой символ из указанного набора.
- **|**: обозначает логическое «или».

Например, регулярное выражение **/^\d+/** будет искать любую цифру, которая находится в начале строки. А регулярное выражение **/[aeiou]/** будет искать любую гласную букву.

Зная эти символы и комбинации, можно создавать более сложные регулярные выражения для поиска нужных паттернов в строках.


# 2. Методы работы со строкой: replace, match, search

В JavaScript существует несколько методов для работы со строками, в том числе **replace**, **match** и **search**.

## 2.1. Метод replace
используется для поиска и замены подстрок в строке. Синтаксис метода выглядит следующим образом:
```ts
str.replace(regexp|substr, newSubStr|function)
```

Первый аргумент может быть как регулярным выражением, так и простой подстрокой. Если первый аргумент — регулярное выражение, то все найденные совпадения будут заменены на указанную строку или результат выполнения функции. Например, заменим в строке "JavaScript is the best programming language" все буквы "a" на символ "-":
```ts
const str = "JavaScript is the best programming language";
const result = str.replace(/a/g, "-");
console.log(result); // "Jv-Script is the best progrmming lnguge"
```

## 2.2. Метод match
используется для поиска совпадений в строке. Синтаксис метода:
```ts
str.match(regexp)
```

Аргументом метода является регулярное выражение. Метод возвращает массив с найденными совпадениями или null, если совпадений не найдено. Например, найдем все цифры в строке "JavaScript 123":
```ts
const str = "JavaScript 123";
const result = str.match(/\d/g);
console.log(result); // ["1", "2", "3"]
```

## 2.3. Метод search
используется для поиска первого вхождения подстроки в строке. Синтаксис метода:
```ts
str.search(regexp)
```

Аргументом метода является регулярное выражение. Метод возвращает индекс первого вхождения подстроки или -1, если подстрока не найдена. Например, найдем индекс первого вхождения слова "best" в строке "JavaScript is the best programming language":
```ts
const str = "JavaScript is the best programming language";
const result = str.search(/best/);
console.log(result); // 18
```

# Middle
# 1. Глобальный объект ReqExp и его методы
Объект RegExp в JavaScript представляет собой регулярное выражение, используемое для поиска и сопоставления строк с определенным шаблоном. Глобальный объект RegExp предоставляет несколько методов для работы с регулярными выражениями:

1. `exec()`: используется для поиска совпадений в строке с заданным регулярным выражением. Он возвращает первое совпадение или `null`, если совпадений не найдено.

2. `test()`: проверяет, соответствует ли строка заданному регулярному выражению. Он возвращает `true`, если строка соответствует выражению, и `false` в противном случае.

3. `toString()`: метод возвращает строковое представление регулярного выражения.

4. `compile()`: метод используется для изменения и компиляции регулярного выражения.

Регулярные выражения также поддерживают некоторые флаги, которые можно использовать вместе с методами объекта RegExp:

1. флаг `g` указывает, что поиск должен производиться глобально (несколько совпадений).

2. флаг `i` указывает, что поиск должен производиться без учета регистра символов.

3. флаг `m` указывает, что поиск должен производиться с учетом многострочных строк.

Пример использования методов объекта RegExp:
```js
const str = 'JavaScript is a programming language';

const regex = /javascript/i;
console.log(regex.test(str)); // true

const regex2 = /a/g;
console.log(str.match(regex2)); // ['a', 'a', 'a']

```

В этом примере мы создаем регулярное выражение `/javascript/i`, которое ищет слово `'javascript'` без учета регистра в строке `str`. Затем мы используем метод `test()` для проверки соответствия строки регулярному выражению.

Затем мы создаем регулярное выражение `/a/g`, которое ищет все буквы `'a'` в строке `str`. Затем мы используем метод `match()` для поиска всех совпадений с регулярным выражением. Результатом будет массив `['a', 'a', 'a']`.

# 2. Группировки _(х)_
Группировки в регулярных выражениях в JavaScript обозначаются круглыми скобками `()`. Они используются для группировки элементов в регулярном выражении и позволяют применять к группе квантификаторы, а также применять к ней операции, такие как "или" (`|`), "ноль или один" (`?`), "один или более" (`+`) и "ноль или более" (`*`).

Группировки могут быть полезны во многих случаях, например, для извлечения подстрок из исходной строки или для нахождения совпадений в определенной последовательности символов.

Вот несколько примеров использования группировок в регулярных выражениях:

1. Извлечение подстроки из строки:
```js
const str = 'My email is john@example.com';
const regex = /(\w+)@(\w+\.\w+)/;
const matches = str.match(regex);
console.log(matches); // ["john@example.com", "john", "example.com"]
```

В этом примере мы создаем регулярное выражение, которое ищет адрес электронной почты в строке `str`. С помощью группировок мы можем извлечь имя пользователя и доменное имя из адреса электронной почты.

2. Нахождение совпадений в определенной последовательности символов:
```js
const str = 'The quick brown fox jumps over the lazy dog';
const regex = /(brown|red) (fox|dog)/;
const matches = str.match(regex);
console.log(matches); // ["brown fox", "brown", "fox"]
```

В этом примере мы создаем регулярное выражение, которое ищет словосочетание `"brown fox"` или `"red dog"` в строке `str`. С помощью группировок мы можем использовать оператор "или" (`|`) для указания нескольких вариантов совпадения. В результате мы получаем совпадение `"brown fox"` и значения групп `"brown"` и `"fox"`.

Обратите внимание, что значения групп доступны в результате выполнения метода `match()` в виде элементов массива, начиная со второго. Первый элемент массива содержит всю найденную подстроку.

# 3. Наборы и диапазоны
Наборы и диапазоны используются в регулярных выражениях в JavaScript для задания групп символов, которые должны совпадать с шаблоном.

**Набор** символов определяется в квадратных скобках `[]`. Наборы могут содержать отдельные символы, а также диапазоны символов, которые определяются через дефис -. Например, набор `[abc]` соответствует любому символу из множества `a`, `b` и `c`, а набор `[a-z]` соответствует любому символу в нижнем регистре от `a` до `z`.

Пример использования наборов:
```js
const str = 'The quick brown fox jumps over the lazy dog';
const regex = /[aeiou]/g;
const matches = str.match(regex);
console.log(matches); // ["e", "u", "i", "o", "o", "u", "o", "e", "o", "e", "a"]
```

В этом примере мы создаем регулярное выражение, которое ищет любую гласную букву в строке str. С помощью набора [aeiou] мы указываем, что ищем любой символ из множества гласных букв.

**Диапазоны** символов также задаются в квадратных скобках `[]`, но вместо отдельных символов они задают диапазон символов через дефис `-`. Например, диапазон `[0-9]` соответствует любой цифре от 0 до 9.

Пример использования диапазонов:
```js
const str = 'The quick brown fox jumps over the lazy dog 123 times';
const regex = /\d+/g;
const matches = str.match(regex);
console.log(matches); // ["123"]
```

В этом примере мы создаем регулярное выражение, которое ищет любую последовательность цифр в строке `str`. С помощью диапазона `\d` мы указываем, что ищем любую цифру от 0 до 9. С помощью квантификатора `+` мы указываем, что ищем одну или более цифр подряд.

# 4. Квантификаторы - _х*, х?_ и другие
Квантификаторы в регулярных выражениях в JavaScript используются для указания количества повторений определенного символа или группы символов.

**Квантификатор `*`** указывает, что символ или группа символов должны повторяться ноль или более раз. Например, выражение `/ab*c/` соответствует строкам `ac`, `abc`, `abbc`, `abbbc`, и т.д.

Пример использования квантификатора `*`:
```js 
const str = 'abbcccd';
const regex = /ab*c/g;
const matches = str.match(regex);
console.log(matches); // ["abb", "abc"]
```

**Квантификатор `+`** указывает, что символ или группа символов должны повторяться один или более раз. Например, выражение `/ab+c/` соответствует строкам `abc`, `abbc`, `abbbc`, и т.д., но не соответствует строке `ac`.

Пример использования квантификатора `+`:
```js
const str = 'abbcccd';
const regex = /ab+c/g;
const matches = str.match(regex);
console.log(matches); // ["abc"]
```

**Квантификатор `?`** указывает, что символ или группа символов должны повторяться ноль или один раз. Например, выражение `/ab?c/` соответствует строкам `ac` и `abc`, но не соответствует строкам `abbc`, `abbbc`, и т.д.

Пример использования квантификатора `?`:
```js
const str = 'abbcabc';
const regex = /ab?c/g;
const matches = str.match(regex);
console.log(matches); // ["abc", "ac", "abc"]
```

**Квантификатор `{n}`** указывает, что символ или группа символов должны повторяться ровно n раз. Например, выражение `/a{3}/` соответствует строке `aaa`.

Пример использования квантификатора `{n}`:
```js
const str = 'aaabaaa';
const regex = /a{3}/g;
const matches = str.match(regex);
console.log(matches); // ["aaa"]
```

**Квантификатор `{n,m}`** указывает, что символ или группа символов должны повторяться от n до m раз включительно. Например, выражение `/a{2,4}/` соответствует строкам `aa`, `aaa`, и `aaaa`.

Пример использования квантификатора `{n,m}`:
```js
const str = 'aaabaaa';
const regex = /a{2,3}/g;
const matches = str.match(regex);
console.log(matches); // ["
```


# Middle+
# 1. Границы слова в регулярном выражении
Границы слова в регулярном выражении в JavaScript могут быть определены с помощью специальных символов. Эти символы позволяют искать только те слова, которые соответствуют заданной границе.

Символы границы слова в регулярных выражениях:

1. `\b`: Соответствует границе слова. Слово - это любая последовательность символов, разделенных пробелами или другими символами пунктуации.
2. `\B`: Соответствует месту, которое не является границей слова.

Примеры использования символов границы слова:
```js
const str = "Hello, world! How are you today?";
const regex = /\bwo\w*\b/g; // соответствует слову "world"
const matches = str.match(regex);
console.log(matches); // ["world"]
```

В этом примере регулярное выражение `/ \b wo \w* \b /g` соответствует слову, которое начинается с символов "wo" и заканчивается на границе слова. Это означает, что оно соответствует только слову "world" в строке.

```js
const str = "Hello, world! How are you today?";
const regex = /\Bwo\w*\B/g; // не соответствует слову "world"
const matches = str.match(regex);
console.log(matches); // null
```

В этом примере регулярное выражение `/ \B wo \w* \B /g` не соответствует слову, которое начинается с символов "wo" и заканчивается не на границе слова. Поэтому в результате поиска ничего не найдено и возвращается `null`.

# 2. Обратные ссылки
Обратные ссылки - это механизм в регулярных выражениях, который позволяет использовать результаты предыдущих поисковых шаблонов в текущем шаблоне.

Для создания обратной ссылки используется специальный синтаксис, который заключает номер группы за символами `\` и `(`. Например, `\1` обозначает ссылку на первую группу в регулярном выражении.

Пример использования обратной ссылки:
```js
const str = "abba";
const regex = /(.)\1/g;
const matches = str.match(regex);
console.log(matches); // ["bb"]
```

В этом примере регулярное выражение `/ (.) \1 /g` соответствует любому символу, который повторяется дважды. Выражение `(.)` создает группу, которая захватывает любой символ, а обратная ссылка `\1` используется для поиска повторяющегося символа.

Таким образом, регулярное выражение `/ (.) \1 /g` находит все повторяющиеся символы в строке "abba" и возвращает массив соответствующих совпадений, в данном случае - только "bb".

# Senior
# 1. Оптимизация производительности регулярных выражений (жадный и ленивый поиск, критический возврат)

Регулярные выражения могут иметь большое влияние на производительность веб-приложений. Неправильное использование регулярных выражений может привести к тому, что они будут работать медленно, блокировать поток выполнения и вызывать другие проблемы. В этом контексте рассмотрим несколько оптимизаций, которые могут улучшить производительность регулярных выражений.

1. **Жадный и ленивый поиск**

Жадный поиск обычно является наиболее эффективным способом поиска совпадений, так как он выполняется быстрее ленивого поиска. Жадный поиск пытается найти максимальное количество символов, удовлетворяющих шаблону. В то время как ленивый поиск находит наименьшее количество символов, удовлетворяющих шаблону.

Например, рассмотрим следующий пример:

```javascript
const text = "Hello, world! Hello, world!";
const pattern = /Hello.*world/;
console.log(text.match(pattern));
```

В этом примере используется жадный поиск, и результат будет следующим:

```
["Hello, world! Hello, world!"]
```

Теперь рассмотрим пример с ленивым поиском:

```javascript
const text = "Hello, world! Hello, world!";
const pattern = /Hello.*?world/;
console.log(text.match(pattern));
```

Результатом ленивого поиска будет:

```
["Hello, world"]
```

2. **Критический возврат**

Критический возврат – это механизм, который предотвращает поиск, когда нет совпадений в определенной части строки. Это может ускорить процесс поиска в случае, когда шаблон не может быть найден в строке.

3. **Кэширование регулярных выражений**

Повторное использование регулярных выражений может значительно ускорить их выполнение. Для этого можно кэшировать регулярные выражения в переменных и использовать их в нескольких местах вашего кода.

4. **Оптимизация поиска**

Для оптимизации поиска можно использовать простые шаблоны вместо сложных, которые требуют много времени на выполнение. Также можно использовать более эффективные способы поиска, такие как метод `indexOf()` для поиска подстрок.

# 2. Опережающие и ретроспективные проверки

Опережающие и ретроспективные проверки - это специальные конструкции в регулярных выражениях, которые позволяют проверять, находится ли определенный текст перед или после другого текста без включения этого текста в результат.

Опережающие проверки (positive lookahead) представляются в виде "(?=pattern)", где "pattern" - это искомый шаблон, находящийся после текущей позиции. Например, регулярное выражение "foo(?=bar)" будет соответствовать строке "foobar", но не строке "foobaz".

Пример:

```javascript
const str = "The quick brown fox jumps over the lazy dog";
const regex = /\b\w+(?= fox\b)/g;
const result = str.match(regex);
console.log(result); // ["brown"]
```

В данном примере мы ищем слова, которые находятся перед словом "fox" с помощью опережающей проверки "(?= fox\b)".

Ретроспективные проверки (positive lookbehind) представляются в виде "(?<=pattern)", где "pattern" - это искомый шаблон, находящийся перед текущей позицией. Например, регулярное выражение "(?<=foo)bar" будет соответствовать строке "foobar", но не строке "bazbar".

Пример:

```javascript
const str = "The quick brown fox jumps over the lazy dog";
const regex = /(?<=quick )\b\w+\b/g;
const result = str.match(regex);
console.log(result); // ["brown"]
```

В данном примере мы ищем слова, которые находятся после слова "quick" с помощью ретроспективной проверки "(?<=quick )".

Опережающие и ретроспективные проверки могут быть очень полезны при поиске текста в сложных сценариях, когда вам нужно найти только те вхождения, которые находятся перед или после определенного текста, но не включают его в результат. Однако, если использовать их неправильно или слишком часто, они могут существенно замедлить производительность вашего приложения.
