# Junior

## Методы поиска DOM узлов
getElementById(id): Поиск элемента по его уникальному идентификатору (ID).

getElementsByClassName(className): Поиск элементов по имени класса.

getElementsByTagName(tagName): Поиск элементов по имени тега.

querySelector(selector): Поиск первого элемента, соответствующего указанному CSS-подобному селектору.

querySelectorAll(selector): Поиск всех элементов, соответствующих указанному CSS-подобному селектору.

parentNode: Получение родительского элемента.

children: Получение коллекции дочерних элементов.

nextSibling: Получение следующего соседнего элемента.

previousSibling: Получение предыдущего соседнего элемента.

classList: Доступ к классам элемента в виде объекта, позволяющего добавлять, удалять, проверять наличие классов и манипулировать ими.

## Методы изменения содержимого в DOM узлах
innerHTML: Это свойство, позволяющее устанавливать или получать HTML-содержимое элемента. Можно использовать для изменения содержимого элементов списком путем установки нового значения HTML-кода.

textContent или innerText: Это свойства, позволяющие устанавливать или получать текстовое содержимое элемента. Можно использовать для изменения текстового содержимого элементов списком путем установки нового значения текста.

appendChild(): Метод, позволяющий добавить новый узел в конец списка дочерних элементов указанного элемента. Можно использовать для добавления новых элементов в список.

insertBefore(): Метод, позволяющий вставить новый узел перед указанным дочерним элементом указанного элемента. Можно использовать для вставки новых элементов в определенное место в списке.

removeChild(): Метод, позволяющий удалить указанный дочерний элемент из списка дочерних элементов указанного элемента. Можно использовать для удаления элементов из списка.

setAttribute(): Метод, позволяющий устанавливать значение атрибута указанного элемента. Можно использовать для изменения атрибутов элементов списком путем установки новых значений.

classList: Это свойство, предоставляющее доступ к классам элемента в виде объекта, который содержит методы для добавления, удаления, переключения и проверки наличия классов. Можно использовать для изменения классов элементов списком.

## Основные браузерные события
click: Событие, возникающее при клике на элементе мышью.

keydown / keyup: События, возникающие при нажатии / отпускании клавиши на клавиатуре.

submit: Событие, возникающее при отправке формы.

change: Событие, возникающее при изменении значения элемента формы, такого как input, select или textarea.

load: Событие, возникающее при полной загрузке ресурсов веб-страницы, таких как изображения, стили, скрипты и т. д.

unload: Событие, возникающее перед выгрузкой веб-страницы или при закрытии окна браузера.

mouseover / mouseout: События, возникающие при наведении мыши на элемент и при уходе мыши с элемента соответственно.

scroll: Событие, возникающее при прокрутке содержимого элемента.

resize: Событие, возникающее при изменении размеров окна браузера.

contextmenu: Событие, возникающее при вызове контекстного меню на элементе, обычно при нажатии правой кнопки мыши.

# Junior+
1. Всплытие и погружение событий
Всплытие (bubbling) и погружение (capturing) - это два механизма обработки событий в JavaScript, которые определяют порядок передачи событий вдоль DOM-дерева от элемента-цели (target) события до его родительских элементов или наоборот.

Всплытие событий (bubbling) - это механизм, при котором событие сначала обрабатывается на самом вложенном элементе (цели события), а затем передается вверх по DOM-дереву через родительские элементы до корневого элемента (обычно это window объект). То есть, событие "всплывает" от цели события к верхним родительским элементам.

Погружение событий (capturing) - это механизм, при котором событие сначала обрабатывается на корневом элементе (обычно это window объект), а затем передается вниз по DOM-дереву до цели события, проходя через родительские элементы. То есть, событие "погружается" от корневого элемента к цели события.

Порядок всплытия и погружения событий может быть определен с помощью метода addEventListener при регистрации обработчиков событий. По умолчанию, события в JavaScript всплывают, то есть всплытие событий включено, а погружение событий выключено.

Пример использования всплытия событий:
```js
document.getElementById('childElement').addEventListener('click', function(event) {
  console.log('Обработчик на дочернем элементе');
});

document.getElementById('parentElement').addEventListener('click', function(event) {
  console.log('Обработчик на родительском элементе');
});
```
Если кликнуть на элемент с id childElement, то сначала будет вызван обработчик на дочернем элементе, а затем обработчик на родительском элементе.

Пример использования погружения событий:
```js
document.getElementById('childElement').addEventListener('click', function(event) {
  console.log('Обработчик на дочернем элементе');
}, true);

document.getElementById('parentElement').addEventListener('click', function(event) {
  console.log('Обработчик на родительском элементе');
}, true);
```
Если кликнуть на элемент с id childElement, то сначала будет вызван обработчик на родительском элементе, а затем обработчик на дочернем элементе, так как погружение событий включено (параметр true в методе addEventListener).

2. Нативная обработка форм и полей
Нативная обработка форм и полей в JavaScript включает использование стандартных API DOM (Document Object Model) для доступа, манипуляции и обработки форм и полей веб-страницы.

Метод getElementById(id): Этот метод позволяет получить доступ к элементу формы или полю по его уникальному идентификатору (id), который задан в атрибуте id элемента. Например:
```js
var inputElement = document.getElementById('myInput'); // Получение доступа к элементу с id "myInput"
Методы доступа к свойствам и атрибутам элементов: С помощью стандартных свойств и атрибутов элементов DOM, таких как value, checked, selectedIndex и других, можно получить и установить значения полей формы. Например:
var inputValue = inputElement.value; // Получение значения поля ввода
inputElement.value = 'Новое значение'; // Установка нового значения поля ввода
Событие submit: Это событие возникает при отправке формы. Можно зарегистрировать обработчик этого события на элементе формы, чтобы выполнить необходимые действия при отправке формы. Например:
var formElement = document.getElementById('myForm'); // Получение доступа к элементу формы
formElement.addEventListener('submit', function(event) {
  // Обработчик события отправки формы
  event.preventDefault(); // Отмена стандартного действия отправки формы
  // Дополнительные действия при отправке формы
});
События input, change, focus, blur и другие: Эти события возникают при изменении значений полей формы, фокусе на полях, потере фокуса и других действиях с формой. Можно зарегистрировать обработчики этих событий на элементах формы, чтобы реагировать на изменения состояния полей формы. Например:
inputElement.addEventListener('input', function(event) {
  // Обработчик события изменения значения поля ввода
});
```

# Middle
1. Живые коллекции, методы обработки и преобразования в массив
Живые коллекции в JavaScript (также известные как коллекции в реальном времени) - это специальные объекты, предоставляемые браузером, которые автоматически отслеживают изменения DOM и предоставляют доступ к элементам, удовлетворяющим определенному условию. Живые коллекции могут быть использованы для динамического отслеживания и манипуляции элементами DOM, которые соответствуют определенному критерию, без явного перебора или обновления.

Некоторые из наиболее распространенных живых коллекций в JavaScript включают:

HTMLCollection: Это коллекция, которая представляет набор элементов DOM, возвращаемых методами getElementById, getElementsByClassName, getElementsByTagName, getElementsByTagNameNS и другими. HTMLCollection является живой коллекцией, так как автоматически обновляется при изменениях DOM.
Пример использования HTMLCollection:
```js
var elements = document.getElementsByClassName('myClass'); // Получение всех элементов с классом "myClass"
console.log(elements.length); // Вывод количества элементов
console.log(elements[0]); // Вывод первого элемента
```
NodeList: Это коллекция, которая представляет набор узлов DOM, возвращаемых методами querySelector и querySelectorAll. NodeList также является живой коллекцией.
Пример использования NodeList:

```js
var elements = document.querySelectorAll('.myClass'); // Получение всех элементов с классом "myClass"
console.log(elements.length); // Вывод количества элементов
console.log(elements[0]); // Вывод первого элемента
```
Методы обработки и преобразования живых коллекций в массив в JavaScript включают:

Преобразование в массив: Живые коллекции можно преобразовать в обычные массивы с помощью оператора распространения (...) или методов Array.from() или Array.prototype.slice.call(). Например:
```js
var elements = document.getElementsByClassName('myClass'); // Получение всех элементов с классом "myClass"
var elementsArray = [...elements]; // Преобразование HTMLCollection в массив с помощью оператора распространения
```
Методы массивов: После преобразования живых коллекций в массивы, можно использовать стандартные методы массивов, такие как forEach(), map(), filter() и другие, для обработки элементов коллекции. Например:
```js
var elements = document.getElementsByClassName('myClass'); // Получение всех элементов с классом "myClass"
var elementsArray = Array.from(elements); // Преобразование HTMLCollection
```
2. Предотвращение механизма всплытия, делегировании событий
Для предотвращения механизма всплытия событий в JavaScript можно использовать метод stopPropagation() на объекте события (event object). Этот метод останавливает всплытие события от текущего элемента до его родительских элементов.

Пример использования stopPropagation():
```js
document.getElementById('myButton').addEventListener('click', function(event) {
  console.log('Button clicked!');
  event.stopPropagation(); // Остановка всплытия события
});
```
В данном примере, при клике на кнопку с id "myButton", будет выведено сообщение "Button clicked!", и всплытие события будет остановлено, так что обработчики событий на родительских элементах не будут вызваны.

Что касается делегирования событий, это подход, при котором один обработчик событий назначается на родительский элемент, и этот обработчик будет срабатывать при наступлении событий на его потомках. Делегирование событий может быть полезным, когда у вас есть множество элементов, на которых нужно отслеживать одинаковые события, например, когда есть список элементов или таблица.

Пример использования делегирования событий:
```js
document.getElementById('myList').addEventListener('click', function(event) {
  if (event.target.tagName === 'LI') { // Проверка, что кликнутый элемент является <li>
    console.log('List item clicked:', event.target.textContent);
  }
});
```
В данном примере, обработчик событий назначается на родительский элемент с id "myList", и при клике на любой из его потомков <li>, будет выведено сообщение "List item clicked:" с текстом содержимого <li>. Это позволяет отслеживать клики на динамически добавляемых элементах списка, без необходимости назначать отдельные обработчики на каждый элемент.

# Middle+
# 1. MutationObserve

MutationObserver - это объект в JavaScript, который позволяет отслеживать изменения в дереве DOM (Document Object Model) и реагировать на эти изменения с помощью обработчиков событий. MutationObserver предоставляет эффективный способ мониторинга изменений в DOM и реагирования на них, без необходимости постоянно проверять DOM вручную на наличие изменений.

Основное применение MutationObserver - это отслеживание изменений в реальном времени, таких как добавление, удаление, изменение атрибутов или текстового содержимого элементов DOM, изменение стилей, и т. д. MutationObserver может быть использован во множестве сценариев, таких как:

1. Отслеживание динамически добавляемых или удаляемых элементов DOM и автоматическая реакция на эти изменения.
2. Автоматическое обновление пользовательского интерфейса при изменении состояния DOM, таких как изменение данных, связанных с элементами DOM.
3. Реагирование на изменения в виде анимаций, валидации форм, динамического обновления содержимого и других сценариев, где требуется отслеживание изменений DOM и реакция на них.

Пример использования MutationObserver:

```ts
// Создание экземпляра MutationObserver с функцией-обработчиком
const observer = new MutationObserver(function(mutations) {
  mutations.forEach(function(mutation) {
    console.log('Изменение в DOM:', mutation);
    // Здесь можно выполнить нужные действия в ответ на изменение DOM
  });
});

// Настройка наблюдения за DOM элементом
const targetElement = document.getElementById('myElement');
const config = { attributes: true, childList: true, subtree: true };
observer.observe(targetElement, config);

// Остановка наблюдения
// observer.disconnect();
```

В данном примере, создается экземпляр MutationObserver с функцией-обработчиком, которая будет вызываться при каждом изменении DOM элемента с id "myElement" и его потомков. Можно указывать различные опции в конфигурации (параметр `config`), такие как отслеживание изменений атрибутов, добавление/удаление дочерних элементов и даже отслеживание изменений в поддереве DOM. При каждом изменении будет вызываться функция-обработчик с объектами `MutationRecord`, содержащими информацию об изменении DOM.

# 2. Selection и Range

Объекты `Selection` и `Range` предоставляют возможность работы с выделением на странице.

Объект `Selection` представляет текущее выделение на странице и содержит информацию о выделенном тексте или элементах. Он может содержать несколько диапазонов (`Range`) выделения.

Пример создания объекта `Selection`:

```javascript
let selection = window.getSelection();
```

Для работы с текущим диапазоном выделения можно использовать методы объекта `Selection`, такие как `getRangeAt(index)` и `addRange(range)`.

Пример использования методов объекта `Selection`:

```javascript
let range = document.createRange();
range.selectNode(document.getElementsByTagName('div')[0]);

let selection = window.getSelection();
selection.removeAllRanges();
selection.addRange(range);
```

Объект `Range` представляет собой диапазон выделения на странице, который можно использовать для работы с текстом или элементами внутри диапазона. Диапазон может быть создан различными способами, например, с помощью метода `document.createRange()` или метода объекта `Selection` `getRangeAt(index)`.

Пример создания объекта `Range`:

```ts
let range = document.createRange();
range.selectNode(document.getElementsByTagName('div')[0]);
```

Методы объекта `Range`, такие как `insertNode(node)` и `deleteContents()`, позволяют изменять содержимое диапазона выделения.

Пример использования методов объекта `Range`:

```ts
let range = document.createRange();
range.selectNode(document.getElementsByTagName('div')[0]);

let span = document.createElement('span');
span.innerHTML = 'new text';

range.deleteContents();
range.insertNode(span);
```

Объекты `Selection` и `Range` позволяют работать с выделением на странице, делая возможной манипуляцию текстом и элементами внутри диапазона выделения.
