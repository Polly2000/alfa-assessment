# Junior
# 1. Методы поиска DOM узлов


**getElementById(id)**: Поиск элемента по его уникальному идентификатору (ID).

**getElementsByClassName(className)**: Поиск элементов по имени класса.

**getElementsByTagName(tagName)**: Поиск элементов по имени тега.

**querySelector(selector)**: Поиск первого элемента, соответствующего указанному CSS-подобному селектору.

**querySelectorAll(selector)**: Поиск всех элементов, соответствующих указанному CSS-подобному селектору.

**parentNode**: Получение родительского элемента.

**children**: Получение коллекции дочерних элементов.

**nextSibling**: Получение следующего соседнего элемента.

**previousSibling**: Получение предыдущего соседнего элемента.

**classList**: Доступ к классам элемента в виде объекта, позволяющего добавлять, удалять, проверять наличие классов и манипулировать ими.


# 2. Методы изменения содержимого в DOM узлах

**innerHTML**: Это свойство, позволяющее устанавливать или получать HTML-содержимое элемента. Можно использовать для изменения содержимого элементов списком путем установки нового значения HTML-кода.

**textContent** или **innerText**: Это свойства, позволяющие устанавливать или получать текстовое содержимое элемента. Можно использовать для изменения текстового содержимого элементов списком путем установки нового значения текста.

**appendChild()**: Метод, позволяющий добавить новый узел в конец списка дочерних элементов указанного элемента. Можно использовать для добавления новых элементов в список.

**insertBefore()**: Метод, позволяющий вставить новый узел перед указанным дочерним элементом указанного элемента. Можно использовать для вставки новых элементов в определенное место в списке.

**removeChild()**: Метод, позволяющий удалить указанный дочерний элемент из списка дочерних элементов указанного элемента. Можно использовать для удаления элементов из списка.

**setAttribute()**: Метод, позволяющий устанавливать значение атрибута указанного элемента. Можно использовать для изменения атрибутов элементов списком путем установки новых значений.

**classList**: Это свойство, предоставляющее доступ к классам элемента в виде объекта, который содержит методы для добавления, удаления, переключения и проверки наличия классов. Можно использовать для изменения классов элементов списком.

# 3. Основные браузерные события
**click**: Событие, возникающее при клике на элементе мышью.

**keydown / keyup**: События, возникающие при нажатии / отпускании клавиши на клавиатуре.

**submit**: Событие, возникающее при отправке формы.

**change**: Событие, возникающее при изменении значения элемента формы, такого как input, select или textarea.

**load**: Событие, возникающее при полной загрузке ресурсов веб-страницы, таких как изображения, стили, скрипты и т. д.

**unload**: Событие, возникающее перед выгрузкой веб-страницы или при закрытии окна браузера.

**mouseover / mouseout**: События, возникающие при наведении мыши на элемент и при уходе мыши с элемента соответственно.

**scroll**: Событие, возникающее при прокрутке содержимого элемента.

**resize**: Событие, возникающее при изменении размеров окна браузера.

**contextmenu**: Событие, возникающее при вызове контекстного меню на элементе, обычно при нажатии правой кнопки мыши.

# Junior+
# 1. Всплытие и погружение событий

Всплытие (bubbling) и погружение (capturing) - это два механизма обработки событий в JavaScript, которые определяют порядок передачи событий вдоль DOM-дерева от элемента-цели (target) события до его родительских элементов или наоборот.

Всплытие событий (bubbling) - это механизм, при котором событие сначала обрабатывается на самом вложенном элементе (цели события), а затем передается вверх по DOM-дереву через родительские элементы до корневого элемента (обычно это `window` объект). То есть, событие "всплывает" от цели события к верхним родительским элементам.

Погружение событий (capturing) - это механизм, при котором событие сначала обрабатывается на корневом элементе (обычно это `window` объект), а затем передается вниз по DOM-дереву до цели события, проходя через родительские элементы. То есть, событие "погружается" от корневого элемента к цели события.

Порядок всплытия и погружения событий может быть определен с помощью метода `addEventListener` при регистрации обработчиков событий. По умолчанию, события в JavaScript всплывают, то есть всплытие событий включено, а погружение событий выключено.

Пример использования всплытия событий:

```ts
document.getElementById('childElement').addEventListener('click', function(event) {
  console.log('Обработчик на дочернем элементе');
});

document.getElementById('parentElement').addEventListener('click', function(event) {
  console.log('Обработчик на родительском элементе');
});
```

Если кликнуть на элемент с id `childElement`, то сначала будет вызван обработчик на дочернем элементе, а затем обработчик на родительском элементе.

Пример использования погружения событий:

```ts
document.getElementById('childElement').addEventListener('click', function(event) {
  console.log('Обработчик на дочернем элементе');
}, true);

document.getElementById('parentElement').addEventListener('click', function(event) {
  console.log('Обработчик на родительском элементе');
}, true);
```

Если кликнуть на элемент с id `childElement`, то сначала будет вызван обработчик на родительском элементе, а затем обработчик на дочернем элементе, так как погружение событий включено (параметр `true` в методе `addEventListener`).

# 2. Нативная обработка форм и полей

Нативная обработка форм и полей в JavaScript включает использование стандартных API DOM (Document Object Model) для доступа, манипуляции и обработки форм и полей веб-страницы. 

1. **Метод `getElementById(id)`**: Этот метод позволяет получить доступ к элементу формы или полю по его уникальному идентификатору (id), который задан в атрибуте `id` элемента. Например:

```javascript
var inputElement = document.getElementById('myInput'); // Получение доступа к элементу с id "myInput"
```

2. **Методы доступа к свойствам и атрибутам элементов**: С помощью стандартных свойств и атрибутов элементов DOM, таких как `value`, `checked`, `selectedIndex` и других, можно получить и установить значения полей формы. Например:

```javascript
var inputValue = inputElement.value; // Получение значения поля ввода
inputElement.value = 'Новое значение'; // Установка нового значения поля ввода
```

3. **Событие `submit`**: Это событие возникает при отправке формы. Можно зарегистрировать обработчик этого события на элементе формы, чтобы выполнить необходимые действия при отправке формы. Например:

```javascript
var formElement = document.getElementById('myForm'); // Получение доступа к элементу формы
formElement.addEventListener('submit', function(event) {
  // Обработчик события отправки формы
  event.preventDefault(); // Отмена стандартного действия отправки формы
  // Дополнительные действия при отправке формы
});
```

4. **События `input`, `change`, `focus`, `blur` и другие**: Эти события возникают при изменении значений полей формы, фокусе на полях, потере фокуса и других действиях с формой. Можно зарегистрировать обработчики этих событий на элементах формы, чтобы реагировать на изменения состояния полей формы. Например:

```javascript
inputElement.addEventListener('input', function(event) {
  // Обработчик события изменения значения поля ввода
});
```

# Middle
# 1. Живые коллекции, методы обработки и преобразования в массив
Живые коллекции в JavaScript (также известные как коллекции в реальном времени) - это специальные объекты, предоставляемые браузером, которые автоматически отслеживают изменения DOM и предоставляют доступ к элементам, удовлетворяющим определенному условию. Живые коллекции могут быть использованы для динамического отслеживания и манипуляции элементами DOM, которые соответствуют определенному критерию, **без явного перебора или обновления**.

Некоторые из наиболее распространенных живых коллекций в JavaScript включают:

1. **`HTMLCollection`**: Это коллекция, которая представляет набор элементов DOM, возвращаемых методами `getElementById`, `getElementsByClassName`, `getElementsByTagName`, `getElementsByTagNameNS` и другими. `HTMLCollection` является живой коллекцией, так как автоматически обновляется при изменениях DOM.

Пример использования `HTMLCollection`:

```ts
var elements = document.getElementsByClassName('myClass'); // Получение всех элементов с классом "myClass"
console.log(elements.length); // Вывод количества элементов
console.log(elements[0]); // Вывод первого элемента
```

2. **`NodeList`**: Это коллекция, которая представляет набор узлов DOM, возвращаемых методами `querySelector` и `querySelectorAll`. `NodeList` также является живой коллекцией.

Пример использования `NodeList`:

```ts
var elements = document.querySelectorAll('.myClass'); // Получение всех элементов с классом "myClass"
console.log(elements.length); // Вывод количества элементов
console.log(elements[0]); // Вывод первого элемента
```

Методы обработки и преобразования живых коллекций в массив в JavaScript включают:

1. **Преобразование в массив**: Живые коллекции можно преобразовать в обычные массивы с помощью оператора распространения (`...`) или методов `Array.from()` или `Array.prototype.slice.call()`. Например:

```ts
var elements = document.getElementsByClassName('myClass'); // Получение всех элементов с классом "myClass"
var elementsArray = [...elements]; // Преобразование HTMLCollection в массив с помощью оператора распространения
```

2. **Методы массивов**: После преобразования живых коллекций в массивы, можно использовать стандартные методы массивов, такие как `forEach()`, `map()`, `filter()` и другие, для обработки элементов коллекции. Например:

```ts
var elements = document.getElementsByClassName('myClass'); // Получение всех элементов с классом "myClass"
var elementsArray = Array.from(elements); // Преобразование HTMLCollection
```

# 2. Предотвращение механизма всплытия, делегировании событий

Для предотвращения механизма всплытия событий в JavaScript можно использовать метод **stopPropagation()** на объекте события (event object). Этот метод останавливает всплытие события от текущего элемента до его родительских элементов.

Пример использования **stopPropagation()**:

```ts
document.getElementById('myButton').addEventListener('click', function(event) {
  console.log('Button clicked!');
  event.stopPropagation(); // Остановка всплытия события
});
```

В данном примере, при клике на кнопку с id "myButton", будет выведено сообщение "Button clicked!", и всплытие события будет остановлено, так что обработчики событий на родительских элементах не будут вызваны.

Что касается делегирования событий, это подход, при котором один обработчик событий назначается на родительский элемент, и этот обработчик будет срабатывать при наступлении событий на его потомках. Делегирование событий может быть полезным, когда у вас есть множество элементов, на которых нужно отслеживать одинаковые события, например, когда есть список элементов или таблица.

Пример использования делегирования событий:

```ts
document.getElementById('myList').addEventListener('click', function(event) {
  if (event.target.tagName === 'LI') { // Проверка, что кликнутый элемент является <li>
    console.log('List item clicked:', event.target.textContent);
  }
});
```

В данном примере, обработчик событий назначается на родительский элемент с id "myList", и при клике на любой из его потомков `<li>`, будет выведено сообщение "List item clicked:" с текстом содержимого `<li>`. Это позволяет отслеживать клики на динамически добавляемых элементах списка, без необходимости назначать отдельные обработчики на каждый элемент.

# Middle+
# 1. MutationObserve

MutationObserver - это объект в JavaScript, который позволяет отслеживать изменения в дереве DOM (Document Object Model) и реагировать на эти изменения с помощью обработчиков событий. MutationObserver предоставляет эффективный способ мониторинга изменений в DOM и реагирования на них, без необходимости постоянно проверять DOM вручную на наличие изменений.

Основное применение MutationObserver - это отслеживание изменений в реальном времени, таких как добавление, удаление, изменение атрибутов или текстового содержимого элементов DOM, изменение стилей, и т. д. MutationObserver может быть использован во множестве сценариев, таких как:

1. Отслеживание динамически добавляемых или удаляемых элементов DOM и автоматическая реакция на эти изменения.
2. Автоматическое обновление пользовательского интерфейса при изменении состояния DOM, таких как изменение данных, связанных с элементами DOM.
3. Реагирование на изменения в виде анимаций, валидации форм, динамического обновления содержимого и других сценариев, где требуется отслеживание изменений DOM и реакция на них.

Пример использования MutationObserver:

```ts
// Создание экземпляра MutationObserver с функцией-обработчиком
const observer = new MutationObserver(function(mutations) {
  mutations.forEach(function(mutation) {
    console.log('Изменение в DOM:', mutation);
    // Здесь можно выполнить нужные действия в ответ на изменение DOM
  });
});

// Настройка наблюдения за DOM элементом
const targetElement = document.getElementById('myElement');
const config = { attributes: true, childList: true, subtree: true };
observer.observe(targetElement, config);

// Остановка наблюдения
// observer.disconnect();
```

В данном примере, создается экземпляр MutationObserver с функцией-обработчиком, которая будет вызываться при каждом изменении DOM элемента с id "myElement" и его потомков. Можно указывать различные опции в конфигурации (параметр `config`), такие как отслеживание изменений атрибутов, добавление/удаление дочерних элементов и даже отслеживание изменений в поддереве DOM. При каждом изменении будет вызываться функция-обработчик с объектами `MutationRecord`, содержащими информацию об изменении DOM.

# 2. Selection и Range

Объекты `Selection` и `Range` предоставляют возможность работы с выделением на странице.

Объект `Selection` представляет текущее выделение на странице и содержит информацию о выделенном тексте или элементах. Он может содержать несколько диапазонов (`Range`) выделения.

Пример создания объекта `Selection`:

```javascript
let selection = window.getSelection();
```

Для работы с текущим диапазоном выделения можно использовать методы объекта `Selection`, такие как `getRangeAt(index)` и `addRange(range)`.

Пример использования методов объекта `Selection`:

```javascript
let range = document.createRange();
range.selectNode(document.getElementsByTagName('div')[0]);

let selection = window.getSelection();
selection.removeAllRanges();
selection.addRange(range);
```

Объект `Range` представляет собой диапазон выделения на странице, который можно использовать для работы с текстом или элементами внутри диапазона. Диапазон может быть создан различными способами, например, с помощью метода `document.createRange()` или метода объекта `Selection` `getRangeAt(index)`.

Пример создания объекта `Range`:

```ts
let range = document.createRange();
range.selectNode(document.getElementsByTagName('div')[0]);
```

Методы объекта `Range`, такие как `insertNode(node)` и `deleteContents()`, позволяют изменять содержимое диапазона выделения.

Пример использования методов объекта `Range`:

```ts
let range = document.createRange();
range.selectNode(document.getElementsByTagName('div')[0]);

let span = document.createElement('span');
span.innerHTML = 'new text';

range.deleteContents();
range.insertNode(span);
```

Объекты `Selection` и `Range` позволяют работать с выделением на странице, делая возможной манипуляцию текстом и элементами внутри диапазона выделения.

# Senior
# 1. WebComponents

Web Components - это набор технологий веб-разработки, которые позволяют создавать переиспользуемые и настраиваемые компоненты пользовательского интерфейса (UI) веб-приложений. Они позволяют создавать компоненты, которые могут быть использованы повторно и легко могут быть интегрированы в различные проекты.

Web Components состоят из трех основных технологий:

**Shadow DOM** - это технология, которая позволяет создавать изолированные DOM-деревья, которые могут быть использованы в компонентах. Это помогает избежать конфликтов между стилями и скриптами на странице.

**Custom Elements** - это технология, которая позволяет создавать свои собственные HTML-элементы. Вы можете создавать элементы, которые имеют свои собственные методы, свойства и события.

**HTML Templates** - это технология, которая позволяет создавать шаблоны, которые могут быть использованы для создания HTML-элементов. Шаблоны могут быть использованы повторно и динамически заполняться данными.

Web Components позволяют создавать компоненты, которые могут быть использованы повторно и легко могут быть интегрированы в различные проекты. Они обеспечивают изоляцию компонентов, упрощают разработку и поддержку кода, улучшают переносимость и совместимость, и снижают вероятность конфликтов и ошибок.


## 1.1 ShodowDom

Shadow DOM - это технология, которая позволяет скрыть внутреннюю реализацию веб-компонента, создавая независимое пространство имен и изолируя его от внешнего DOM-дерева страницы. В основе Shadow DOM лежит идея инкапсуляции, которая позволяет создавать компоненты, чья внутренняя реализация остается скрытой от других компонентов и страницы в целом.

Пример использования Shadow DOM:

```html
<template id="custom-element">
  <style>
    /* стили для Shadow DOM */
    h1 {
      color: red;
    }
  </style>
  <h1>Заголовок компонента</h1>
  <p>Текст компонента</p>
</template>

<script>
  class CustomElement extends HTMLElement {
    constructor() {
      super();

      // создаем Shadow DOM
      const shadowRoot = this.attachShadow({ mode: 'open' });

      // получаем содержимое шаблона
      const template = document.querySelector('#custom-element').content;

      // клонируем содержимое шаблона и добавляем его в Shadow DOM
      shadowRoot.appendChild(template.cloneNode(true));
    }
  }

  // регистрируем новый элемент
  customElements.define('custom-element', CustomElement);
</script>

<!-- использование нового элемента -->
<custom-element></custom-element>
```

В примере мы создаем новый элемент `custom-element` и определяем его в качестве наследника `HTMLElement`. В конструкторе элемента мы создаем новое пространство имен Shadow DOM с помощью метода `attachShadow()`. Затем мы получаем содержимое шаблона с помощью метода `querySelector()` и добавляем его в Shadow DOM с помощью метода `appendChild()`. 

Теперь, если мы откроем инструменты разработчика браузера и посмотрим на элемент `custom-element`, мы увидим, что его содержимое находится внутри `#shadow-root`. При этом стили, определенные в Shadow DOM, будут применяться только к этому элементу и не будут влиять на остальные элементы на странице.

## 1.2 Custom elements

Custom Elements - это новый API браузера, который позволяет разработчикам создавать свои собственные пользовательские HTML-элементы, которые могут быть использованы и повторно использованы в приложениях веб-страниц.

Custom Elements позволяет создавать новые HTML-элементы, которые расширяют функциональность существующих элементов и имеют свою уникальную логику. Они могут быть использованы как любые другие HTML-элементы и настраиваться с помощью атрибутов, свойств, методов и событий.

Пример создания пользовательского элемента:

```ts
class MyElement extends HTMLElement {
  constructor() {
    super();
    this.textContent = 'Hello, world!';
  }
}

customElements.define('my-element', MyElement);
```

В этом примере мы создаем новый HTML-элемент `my-element` и определяем его поведение в классе `MyElement`. После этого мы регистрируем наш новый элемент с помощью метода `customElements.define()`, который позволяет браузеру знать, как обрабатывать наш элемент.

Теперь мы можем использовать наш новый элемент в любом месте нашей веб-страницы:

```html
<my-element></my-element>
```

В результате на странице будет отображен новый элемент с текстом "Hello, world!".

Custom Elements API также предоставляет методы для определения и настройки свойств, методов и событий пользовательских элементов, что делает их еще более гибкими и мощными.


## 1.3 HTML templates 

HTML Templates - это механизм, который позволяет определить кусок HTML, который может быть использован многократно в документе. Они могут быть использованы для определения повторяющегося содержимого, такого как таблицы или формы, и могут быть созданы на стороне клиента или сервера.

Шаблоны HTML создаются с использованием тега <template>, который позволяет определить HTML-код, который должен быть использован позже. Шаблон не отображается на странице, но может быть скопирован и вставлен в документ при необходимости.

Пример использования шаблона HTML:

```html
<template id="my-template">
  <div>
    <h2>Заголовок шаблона</h2>
    <p>Текст шаблона</p>
  </div>
</template>

<!-- Использование шаблона -->
<div id="template-container"></div>

<script>
  // Получаем шаблон по ID
  const template = document.querySelector('#my-template');

  // Создаем новый экземпляр шаблона
  const clone = document.importNode(template.content, true);

  // Добавляем новый экземпляр в контейнер
  const container = document.querySelector('#template-container');
  container.appendChild(clone);
</script>
```

Этот пример создает новый экземпляр шаблона и добавляет его в контейнер на странице. Как видно из кода, шаблон может быть получен по ID с помощью метода `document.querySelector()`, а затем скопирован с помощью метода `document.importNode()`. Клонированный шаблон может быть добавлен в любой элемент на странице с помощью метода `appendChild()`.

HTML Templates также могут быть использованы с JavaScript-фреймворками, такими как React и Vue, для создания компонентов, которые могут быть использованы повторно в приложении.
