# Junior
# 1. Что такое docker, зачем нужен

Docker - это открытая платформа, которая позволяет упаковывать, доставлять и запускать приложения в контейнерах. Контейнеры Docker включают в себя все необходимое для работы приложения, включая код, зависимости, библиотеки и настройки окружения. Docker обеспечивает изолированное окружение для приложений, которое позволяет им работать одинаково независимо от конфигурации хост-системы.

**Основные причины использования Docker:**

1. **Портабельность:** Docker обеспечивает портабельность приложений, позволяя упаковывать их в контейнеры. Контейнеры Docker могут быть запущены на различных платформах и операционных системах без изменений кода или настроек. Это делает приложения портативными и легко переносимыми между различными средами.

2. **Унификация окружения:** Docker позволяет упаковывать приложение вместе с его зависимостями и настройками в контейнер. Это гарантирует однородность окружения при разработке, тестировании и развертывании. Контейнеры Docker избавляют от проблем, связанных с различиями в конфигурации окружения между разработчиками и серверами.

3. **Изолированность и безопасность:** Контейнеры Docker обеспечивают изолированное окружение для приложений. Каждое приложение работает в своем собственном контейнере с отдельными ресурсами и файловой системой. Это повышает безопасность и предотвращает влияние одного приложения на другие.

4. **Масштабируемость и гибкость:** Docker обеспечивает гибкость и масштабируемость при развертывании и управлении приложениями. Вы можете запускать несколько контейнеров с одним и тем же приложением на одном хосте или на нескольких хостах в кластере. Docker также предоставляет инструменты для управления контейнерами, мониторинга ресурсов и автоматического масштабирования.

5. **Упрощение развертывания и обновления:** Docker упрощает процесс развертывания и обновления приложений. Вы можете создавать образы контейнеров, которые содержат все необходимое для работы приложения, и легко развертывать их на любом хосте, поддерживающем Docker. Обновление приложения также становится проще, поскольку вам нужно только обновить образ контейнера.

6. **Эффективное использование ресурсов:** Docker позволяет эффективно использовать ресурсы хоста. Контейнеры используют виртуализацию на уровне операционной системы, что позволяет им запускаться на одном хосте без значительного потребления ресурсов, таких как память и процессорное время.

7. **Упрощение совместной работы и интеграции:** Docker облегчает совместную работу над проектами и интеграцию различных компонентов. Вы можете использовать готовые образы контейнеров из публичных репозиториев Docker Hub или создавать собственные образы и делиться ими с другими участниками проекта.

Использование Docker позволяет ускорить разработку, упрощает развертывание и обновление приложений, обеспечивает консистентность окружения и повышает безопасность приложений.

# Junior+
# 1. Базовые команды:
Вот несколько базовых команд Docker, которые могут быть полезны при работе с контейнерами:

1. `docker run`: Запуск контейнера на основе образа. Например, `docker run hello-world` запустит контейнер с образом "hello-world".

2. `docker build`: Создание собственного образа на основе Dockerfile, описывающего инструкции для сборки образа. Например, `docker build -t my-image:tag .` создаст образ с тегом "my-image:tag" на основе текущего каталога.

3. `docker pull`: Загрузка образа из реестра Docker Hub или другого реестра. Например, `docker pull nginx` загрузит образ NGINX из Docker Hub.

4. `docker images`: Отображение списка доступных образов Docker на хосте.

5. `docker ps`: Отображение списка запущенных контейнеров.

6. `docker exec`: Выполнение команды внутри запущенного контейнера. Например, `docker exec -it my-container bash` запустит интерактивную оболочку внутри контейнера "my-container".

7. `docker stop`: Остановка запущенного контейнера. Например, `docker stop my-container` остановит контейнер с именем "my-container".

8. `docker rm`: Удаление контейнера. Например, `docker rm my-container` удалит контейнер с именем "my-container".

9. `docker rmi`: Удаление образа. Например, `docker rmi my-image:tag` удалит образ с тегом "my-image:tag".

10. `docker-compose`: Инструмент для определения и управления многоконтейнерными приложениями с помощью файла конфигурации YAML. Позволяет определить зависимости и конфигурацию для нескольких контейнеров одновременно.

Это только несколько примеров базовых команд Docker. Docker предоставляет множество других команд и опций для управления контейнерами, образами и другими аспектами работы с Docker.
## 1.1 pull

Команда `docker pull` используется для загрузки (скачивания) образа из реестра Docker. Образы могут быть загружены из Docker Hub или других реестров. Пример использования команды `docker pull`:

- `docker pull nginx`: Загружает образ NGINX из Docker Hub.
- `docker pull my-registry/my-image:tag`: Загружает образ с тегом "tag" из пользовательского реестра с именем "my-registry".

Команда `docker pull` автоматически загружает указанный образ, если он не найден локально. Если образ уже существует локально, команда просто обновляет его, если доступна более новая версия.

## 1.2 run

Команда `docker run` используется для создания и запуска контейнера на основе указанного образа. Вот некоторые основные опции, которые можно использовать с командой `docker run`:

- `-d` или `--detach`: Запускает контейнер в фоновом режиме (detached mode).
- `-p` или `--publish`: Пробрасывает порты между контейнером и хостом. Например, `-p 8080:80` связывает порт 8080 на хосте с портом 80 в контейнере.
- `-v` или `--volume`: Создает привязку (mount) между директорией на хосте и контейнером. Например, `-v /путь/к/локальной/директории:/путь/в/контейнере` позволяет обмениваться данными между хостом и контейнером.
- `-e` или `--env`: Устанавливает переменные среды контейнера. Например, `-e MYSQL_ROOT_PASSWORD=password` задает пароль для пользователя root в контейнере MySQL.

Примеры использования команды `docker run`:

1. `docker run hello-world`: Запускает контейнер с образом "hello-world". Это простой способ проверить, что Docker работает корректно.
2. `docker run -d -p 8080:80 nginx`: Запускает контейнер с образом NGINX в фоновом режиме и пробрасывает порт 8080 на хосте на порт 80 в контейнере.
3. `docker run -v /путь/к/локальной/директории:/путь/в/контейнере image:tag`: Создает привязку между локальной директорией и директорией в контейнере.


# Middle
# 1. Написание Docker-файла
Пример базового Docker-файла:
```Dockerfile
# Используем базовый образ
FROM <base_image>

# Устанавливаем необходимые зависимости
RUN <install_commands>

# Копируем файлы проекта в контейнер
COPY <source> <destination>

# Определяем рабочую директорию
WORKDIR <working_directory>

# Запускаем команду при запуске контейнера
CMD <command>
```

Инструкции Dockerfile и их описание:

1. `FROM`: Определяет базовый образ, на основе которого будет собираться новый образ.
2. `RUN`: Выполняет команды внутри контейнера во время сборки образа. Используется для установки зависимостей, настройки окружения и других операций.
3. `COPY` или `ADD`: Копирует файлы или директории из локальной файловой системы в контейнер.
4. `WORKDIR`: Устанавливает рабочую директорию для последующих инструкций. Все относительные пути будут рассматриваться относительно этой директории.
5. `CMD`: Определяет команду, которая будет выполняться при запуске контейнера.

Это только базовый пример Docker-файла, и его содержимое будет зависеть от конкретного проекта и требований.

После написания Docker-файла, можно использовать команду `docker build` для сборки Docker-образа на основе этого файла.

# 2. Команды для подключения к запущенному контейнеру, просмотр логов
Для подключения к запущенному контейнеру и просмотра его логов в Docker можно использовать следующие команды:

1. Подключение к запущенному контейнеру с использованием команды `docker exec`:
```shell
docker exec -it <CONTAINER_ID> <COMMAND>
```
где `<CONTAINER_ID>` - идентификатор (ID) контейнера, к которому вы хотите подключиться, а `<COMMAND>` - команда, которую вы хотите выполнить внутри контейнера (например, /bin/bash для доступа к командной оболочке контейнера).

Пример:
```shell
docker exec -it my_container /bin/bash
```

2. Просмотр логов контейнера с использованием команды docker logs:
```shell
docker logs <CONTAINER_ID>
```
где <CONTAINER_ID> - идентификатор (ID) контейнера, логи которого вы хотите просмотреть.

Пример:
```shell
docker logs my_container
```

`<CONTAINER_ID>` представляет собой уникальный идентификатор контейнера, который можно получить с помощью команды `docker ps` для активных контейнеров.

После выполнения этих команд мы сможем подключиться к контейнеру или просмотреть его логи в командной строке.


# Middle+
# 1. Что такое multi-stage build
Основная идея **multi-stage build** заключается в том, что мы можем создать Dockerfile, содержащий несколько секций FROM, каждая из которых определяет базовый образ и его окружение для конкретного этапа сборки. После этого мы можем использовать результаты предыдущего этапа в текущем этапе, не сохраняя ненужные файлы или компоненты.

Преимущества использования multi-stage build:
1. Сокращение размера итогового образа: Можно создавать промежуточные образы, содержащие только необходимые компоненты и зависимости для каждого этапа, что помогает сократить размер итогового образа.
2. Упрощение сборки: Можно разделять процесс сборки на несколько этапов, каждый из которых выполняет определенные задачи. Это позволяет упростить настройку и управление процессом сборки.
3. Улучшение безопасности: Используя multi-stage build, можно исключить из итогового образа компоненты и зависимости, которые не требуются на этапе выполнения, тем самым снижая потенциальные уязвимости и атаки.

Пример использования multi-stage build:
```Dockerfile
# Первый этап - сборка и компиляция приложения
FROM node:14 as builder
WORKDIR /app
COPY package.json .
RUN npm install
COPY . .
RUN npm run build

# Второй этап - создание итогового образа
FROM nginx:alpine
COPY --from=builder /app/build /usr/share/nginx/html
```

В этом примере первый этап (builder) использует образ node:14 для сборки и компиляции приложения Node.js. Второй этап использует образ `nginx:alpine` и копирует скомпилированные файлы из предыдущего этапа в каталог `/usr/share/nginx/html`. Результатом будет итоговый Docker-образ, содержащий только необходимые файлы для запуска приложения в Nginx.

Multi-stage build позволяет создавать эффективные и оптимизированные Docker-образы, упрощает процесс сборки и улучшает безопасность.

# 2. docker-compose
Docker Compose - это инструмент для определения и управления многоконтейнерными приложениями с использованием Docker. Он позволяет определить и настроить сервисы, их зависимости, сети и другие аспекты приложения в файле конфигурации в формате YAML.

С помощью Docker Compose можно:
1. Определить множество сервисов: определить все компоненты приложения в файле `docker-compose.yml`, включая контейнеры, сети, тома, переменные окружения и другие параметры.
2. Управлять зависимостями: Docker Compose позволяет определить зависимости между сервисами и контролировать порядок запуска и остановки контейнеров.
3. Конфигурировать сервисы: можно настроить параметры контейнеров, такие как порты, переменные окружения, привязки томов и сетевые настройки, в файле `docker-compose.yml`.
4. Запускать и останавливать приложение: С помощью команд `docker-compose up` и `docker-compose down` можно легко запускать и останавливать все сервисы нашего приложения.
5. Масштабирование сервисов: `Docker Compose` позволяет масштабировать сервисы, указывая количество реплик каждого сервиса, что упрощает горизонтальное масштабирование приложения.

Пример файла `docker-compose.yml`:
```yaml
version: '3'
services:
  web:
    build: .
    ports:
      - "8080:80"
    volumes:
      - ./app:/var/www/html
  db:
    image: mysql:5.7
    environment:
      - MYSQL_ROOT_PASSWORD=secret
```

В этом примере определены два сервиса: `web` и `db`. Сервис `web` собирается из текущей директории, привязывает порт 8080 хоста к порту 80 контейнера и монтирует локальную директорию `./app` в `/var/www/html` внутри контейнера. Сервис `db` использует образ `mysql:5.7` и устанавливает переменную окружения `MYSQL_ROOT_PASSWORD`.

Чтобы запустить приложение с использованием `Docker Compose`, вам нужно выполнить команду `docker-compose up` в директории, содержащей файл `docker-compose.yml`. `Docker Compose` автоматически создаст и запустит все сервисы, определенные в файле.


# Senior
# 1. Как устроены слои в docker-образе

Docker-образы состоят из нескольких слоев, которые объединяются для создания окружения исполнения. Вот краткое описание этих слоев:

1. **Базовый слой (Base Layer)**: Это основа образа, который может быть основан на другом образе или операционной системе. Базовый слой содержит минимальное окружение, необходимое для работы приложения, например, ОС, системные библиотеки и средства исполнения.

2. **Промежуточные слои (Intermediate Layers)**: Промежуточные слои добавляются поверх базового слоя и содержат файлы, пакеты, зависимости и другие ресурсы, необходимые для работы приложения. Каждый шаг в Dockerfile, такой как установка пакетов или копирование файлов, создает новый промежуточный слой. Промежуточные слои являются неизменяемыми и кэшируются для повторного использования при создании и обновлении образа.

3. **Слой контейнера (Container Layer)**: Когда контейнер создается из образа, добавляется дополнительный слой контейнера. Этот слой содержит изменения, внесенные во время работы контейнера, например, созданные файлы, изменения в файловой системе или данные, записанные приложением. Слой контейнера является временным и существует только во время работы контейнера.

Каждый слой в Docker-образе представляет собой файловую систему, содержащую только изменения по сравнению с предыдущим слоем. Это делает работу с образами эффективной и позволяет быстро создавать, обновлять и распространять образы.

При использовании Docker команды `docker build` и `docker push` слои образа отправляются и хранятся в реестре Docker, а при создании и запуске контейнера они объединяются воедино, образуя окружение исполнения.

# 2. docker-swarm

**Docker Swarm (или просто Swarm)** - это инструмент для оркестрации контейнеров, предоставляемый Docker. Он позволяет управлять группой Docker-хостов в кластере и развертывать, масштабировать и управлять контейнеризованными приложениями.

Основные концепции и возможности Docker Swarm включают:

1. **Менеджеры (Managers)**: Менеджеры являются узлами управления в Swarm-кластере. Они обеспечивают централизованное управление и координацию работы контейнеров. Менеджеры могут принимать команды от клиентов, создавать и управлять службами и контейнерами, а также поддерживать состояние кластера.

2. **Рабочие узлы (Workers)**: Рабочие узлы являются узлами выполнения в Swarm-кластере. Они получают задания от менеджеров и запускают контейнеры. Рабочие узлы предоставляют вычислительные ресурсы для развертывания контейнеров.

3. **Службы (Services)**: Службы представляют собой декларативный способ определения и запуска контейнеров в Swarm-кластере. Они определяют количество экземпляров контейнеров, используют образы Docker и настраивают параметры развертывания. Службы могут быть масштабированы, обновлены и управляемы с помощью команд Swarm API или командной строки Docker.

4. **Стеки (Stacks)**: Стеки - это способ организации и развертывания группы связанных служб вместе. Они позволяют определить и управлять несколькими службами, используя файлы конфигурации в формате YAML или Compose.

5. **Отказоустойчивость и автомасштабирование**: Swarm обеспечивает отказоустойчивость и автомасштабирование, позволяя запускать несколько экземпляров контейнеров и распределять их по различным рабочим узлам. Если один узел выходит из строя, Swarm перераспределит контейнеры на другие доступные узлы.

**Docker Swarm** предоставляет удобный способ управления контейнерами в масштабе кластера, облегчая развертывание и управление приложениями. Он предоставляет высокую доступность, отказоустойчивость и возможность масштабирования контейнерных приложений.


